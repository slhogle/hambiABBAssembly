[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "",
    "text": "This project contains data and analysis from the hambiABBAssembly project."
  },
  {
    "objectID": "index.html#manuscript",
    "href": "index.html#manuscript",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "1 Manuscript:",
    "text": "1 Manuscript:\n“TBD”\nPreprint available from bioRxiv"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "2 Introduction",
    "text": "2 Introduction\nPast work has shown that the composition of small bacterial communities can be predicted remarkably well from outcomes of competitions between small sets of species (Friedman, Higgins, and Gore 2017). Other work has questioned whether such simple qualitative assembly rules hold in more complex situations such as when the species pool shares an evolutionary history (Chang et al. 2023) (also see this blog post). If community assembly dynamics can truly be characterized by additive pairwise processes this would be a great advantage for modelers. It would mean that communities could be described sufficiently using paired species interactions (as in traditional Lotka Volterra). However, if higher-order interactions (Levine et al. 2017) are common and important (e.g., species C mediates the interaction between species A and B in a density independent way) then the number of parameters necessary to sufficiently model the system quickly blows up quickly making the entire problem intractable.\nUnderstanding the fundamental processes in community assembly will be key to designing microbial communities with desirable properties for human use and to anticipate the response of communities in nature to change. Two theoretical camps have emerged in contemporary theory; one arguing for pairwise assembly rules and another arguing for the importance of networks of chained pairwise interactions and/or higher order interactions. Evidence exists for both processes occurring in nature. Thus, the question of when/how/why community assembly can be sufficiently described/predicted from additive pairwise processes is relevant and important for gaining a predictive understanding of microbiome dynamics. For example, when will the assembly process emerge as a property of the community, rather than being a straightforward additive process? In particular, do the previous evolutionary history and patterns of coexistence in the species pool determine emergent coexistence? What is the role for different growth conditions (substrate availability, antibacterial compounds, pH, predator presence)? Or does prior adaptive evolution to the environment change the outcomes? Do the “simple” rules governing community assembly fundamentally change as you add more layers of complexity?\nThe goal here is to shed some additional light on the question of the importance of pairwise competition/emergent coexistence in microbiomes. Our experiment assembles all possible 2, 3, and 4 species sub communities from a 4-species pool under a gradient of antibiotic concentrations and with different evolutionary histories of the four species. We assess the predictability of community assembly outcomes based on subsets of the reduced species assemblies and attempt to understand whether assembly operates in a predominantly pairwise way."
  },
  {
    "objectID": "index.html#experiment-overview",
    "href": "index.html#experiment-overview",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "3 Experiment overview",
    "text": "3 Experiment overview\n\n3.1 Background:\nIn prior work from our lab we experimentally evolved all species from the HAMBI synthetic community to increasing concentrations of the aminoglycoside antibiotic streptomycin. Briefly, we would grow each species at the highest streptomycin concentration it could tolerate for a number of growth cycles, then we would transfer into a higher streptomycin. We did this until we reached a streptomycin concentration where we could no longer detect growth. Then these cultures were plated and a single clone was isolated.\nThese clones are the source “evolved” starting materials for this experiment, where their clonal ancestor is the “ancestral” starting material.\n\n\n3.2 Traits and physiology of species:\nThe ancestral and evolved form of each species were grown for 48 hours at 30℃ in 100% R2A growth medium (Reasoner and Geldreich 1985) at concentrations of 0, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, and 4096 μg/ml streptomycin. Growth was followed using optical density at 600 nm in a Bioscreen plate reader. Growth rates and carrying capacities were determined from the high resolution growth curves using AMiGA.\n\n\n3.3 Species interactions:\nThe ancestral and evolved forms of each species were grown for 48 hours at 30℃ in 100% R2A growth medium (Reasoner and Geldreich 1985). Cultures were filtered to remove bacterial biomass and the spent media was stored at 4℃ until use. Next the evolved and ancestral forms of each species were grown in the spent medium of each other evo/anc species for 48 hours at 30℃ and growth was followed using optical density at 600 nm in a Bioscreen plate reader.\nFor the Burkholder diffusion assay we will add each species/evolutionary form to a soft agar on a petri dish. Then a small volume of each species will be pipetted directly onto the agar and plates will be checked for zones of inhibition.\n\n\n3.4 Competition/coexistence outcomes (species proportions from communities):\nHere we wish to ensure that any equilibrium coexistence or competitive exclusion between species is not multistable - meaning that the outcome is deterministic and truly based on the density-independent competitive abilities of the species and not dependent on their starting density. The multistability problem has been addressed in other studies by growing each species from each community at different starting densities. This is typically done by starting all of the rare species at a low density and one abundant species at a higher density (as measured by optical density). For more than 2 species you cannot reasonably achieve all possible permutations of different densities, but you can start each species from rare, while leaving one remaining species high.\nHere we use starting conditions with 10%/90% for pairs, 80%/10%/10% for trios, and 70%/10%/10%/10% for quartets. For pairs, we alternated so that each species started from rare. For trios and quartets, we alternated so that each species was allowed to invade from rare but we did not use all possible staring proportions due to practical and cost limitations. Another important consideration is that we can not distinguish between the ancestral and evolved forms of the same species with amplicon sequencing (or with plate counts) so that our experimental arrangement cannot be fully factorial (e.g., we cannot compete ancestral 1977 against evolved 1977) and thus there are fewer combinations that one would expect from expected scaling of \\(2^{(8-1)} = 128\\)\nFor the coexistence/exclusion experiments experimental communities are inoculated in 500 μl of 100% R2A in deep 96 well plates at a 50 fold dilution at four different streptomycin levels: 0, 16, 64, and 256 μg/ml. Plates were incubated in the dark at 30℃ with shaking at 800 RPM. Serial transfers (50 fold dilution; 10 μl to 490 μl) were conducted every 48 hours for a total of eight growth cycles. For every growth cycle \\(\\mathrm{log_2(50)} \\approx 5.6\\) generations will have elapsed for a total of about 45 generations over eight cycles."
  },
  {
    "objectID": "index.html#measurements-and-data-types",
    "href": "index.html#measurements-and-data-types",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "4 Measurements and data types",
    "text": "4 Measurements and data types\n\n4.1 Traits and physiology of species:\n\nGrowth rates and carrying capacity (in optical density units) of each species (both ancestral/evolved) on a gradient of streptomycin concentrations\n\n\n\n4.2 Species interactions:\n\nGrowth rates and carrying capacity (in optical density units) of each species (both ancestral/evolved) on the filtrate of all other species.\n(NOT YET COMPLETED) Burkholder Diffusion Assays for species pairs to detect presence of interference competition (e.g., antibiotic or toxin production that kills competitors). Note: based on past work with these species we don’t expect to detect significant interference competition.\n\n\n\n4.3 Competition/coexistence outcomes (species proportions from communities):\n\nCommunity DNA from pairs, trios, and quartets was sampled after eight 48 hour growth cycles\n16S rRNA amplicon sequencing was performed on samples to get the proportion of each species\nOptical density was collected at every other growth cycle"
  },
  {
    "objectID": "index.html#code",
    "href": "index.html#code",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "5 Code",
    "text": "5 Code\n Data and code here is provided under GPL3. Feel free to use or remix as you see fit.\n\n5.1 Project structure\n\n/R contains R scripts\n/data contains data that has been processed in some way for later use\n/_data_raw contains unprocessed data scraped from compute cluster\n/figs contains figures generated from R scripts"
  },
  {
    "objectID": "index.html#availability",
    "href": "index.html#availability",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "6 Availability",
    "text": "6 Availability\nThe rendered project site is available at https://slhogle.github.io/hambiABBAssembly/. The website has been produced using Quarto notebooks.\nThis GitHub repository (https://github.com/slhogle/hambiABBAssembly) hosts the code and data for this project. The rendered webpage can be fully recreated using the code."
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "Data anlalysis for the project hambiABBAssembly",
    "section": "7 Reproducibility",
    "text": "7 Reproducibility\nThe project uses renv to create reproducible environment to execute the code in this project. See here for a brief overview on collaboration and reproduction of the entire project. To get up and running you can do:\ninstall.packages(\"renv\")\nrenv::restore()"
  },
  {
    "objectID": "R/experiment_design/03_quartets.html",
    "href": "R/experiment_design/03_quartets.html",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)\n\n\n\n\n\ndata &lt;- here::here(\"data\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\nSpecies color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#libraries",
    "href": "R/experiment_design/03_quartets.html#libraries",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#functions-and-vars",
    "href": "R/experiment_design/03_quartets.html#functions-and-vars",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "Species color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#first-pipetting-step",
    "href": "R/experiment_design/03_quartets.html#first-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.1 First pipetting step",
    "text": "3.1 First pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Layout for the first pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#second-pipetting-step",
    "href": "R/experiment_design/03_quartets.html#second-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.2 Second pipetting step",
    "text": "3.2 Second pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Layout for the second pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#third-pipetting-step",
    "href": "R/experiment_design/03_quartets.html#third-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.3 Third pipetting step",
    "text": "3.3 Third pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Layout for the third pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#fourth-pipetting-step",
    "href": "R/experiment_design/03_quartets.html#fourth-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.4 Fourth pipetting step",
    "text": "3.4 Fourth pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Layout for the fourth pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html",
    "href": "R/experiment_design/01_pairs.html",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)\n\n\n\n\n\ndata &lt;- here::here(\"data\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\nSpecies color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html#libraries",
    "href": "R/experiment_design/01_pairs.html#libraries",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html#functions-and-vars",
    "href": "R/experiment_design/01_pairs.html#functions-and-vars",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "Species color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html#first-pipetting-step",
    "href": "R/experiment_design/01_pairs.html#first-pipetting-step",
    "title": "Designing two-species subcommunities",
    "section": "3.1 First pipetting step",
    "text": "3.1 First pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Layout for the first pipetting step for constructing pairs. Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 90% (e.g., _90) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html#second-pipetting-step",
    "href": "R/experiment_design/01_pairs.html#second-pipetting-step",
    "title": "Designing two-species subcommunities",
    "section": "3.2 Second pipetting step",
    "text": "3.2 Second pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Layout for the second pipetting step for constructing pairs. Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 90% (e.g., _90) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html",
    "title": "Formatting Rbec output",
    "section": "",
    "text": "Contains results from pairs of all streptomycin concentrations and trios for 0 streptomycin from Milla’s bottom up community assembly experiment",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#libraries",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#libraries",
    "title": "Formatting Rbec output",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(archive)\nlibrary(scales)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#global-variables",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#global-variables",
    "title": "Formatting Rbec output",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240711_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240711_BTK_illumina_v3\")\namplicontar &lt;- here::here(data_raw, \"rbec_output.tar.gz\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#data",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#data",
    "title": "Formatting Rbec output",
    "section": "2.3 Data",
    "text": "2.3 Data\nNOTE! We have commented out the species not included in this experiment\n\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#functions",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#functions",
    "title": "Formatting Rbec output",
    "section": "2.4 Functions",
    "text": "2.4 Functions\n\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus)) %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species))) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#untar-rbec-output-tarball",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#untar-rbec-output-tarball",
    "title": "Formatting Rbec output",
    "section": "4.1 Untar Rbec output tarball",
    "text": "4.1 Untar Rbec output tarball\n\narchive::archive_extract(\n  amplicontar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#setup-directory-structure",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#setup-directory-structure",
    "title": "Formatting Rbec output",
    "section": "4.2 Setup directory structure",
    "text": "4.2 Setup directory structure\n\ntabdir &lt;- here::here(tmpdir, \"rbec_output\")\nsamppaths &lt;- fs::dir_ls(tabdir)\nsampnames &lt;- path_split(samppaths) %&gt;% \n  map_chr(dplyr::last)",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#read",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#read",
    "title": "Formatting Rbec output",
    "section": "4.3 Read",
    "text": "4.3 Read\n\nstraintabs &lt;- paste0(samppaths, \"/strain_table.txt\") %&gt;% \n  set_names(sampnames) %&gt;% \n  map_df(\n  read_tsv,\n  skip = 1,\n  col_names = c(\"rRNA16S_locus\",\"count\"),\n  show_col_types = FALSE, \n  .id = \"sample\") %&gt;% \n  # naming scheme inconsistent for one sample\n  mutate(sample = if_else(sample == \"P2_s_0\", \"P02_s_0\", sample))",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#negative-controls",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#negative-controls",
    "title": "Formatting Rbec output",
    "section": "6.1 Negative controls",
    "text": "6.1 Negative controls\nFirst, we’ll check whether the experimental and plate negative controls look good\n\nfinaltable %&gt;% \n  filter(str_detect(community_type, \"^neg|pos\")) %&gt;% \n  summarize(tot = sum(count_correct), .by = c(\"sample\", \"community_id\", \"n_species\", \"community_type\", \"replicate\"))\n\n\n  \n\n\n\nThis looks ok, but there are potentially some problems. Specifically, negative control replicates 2, 3, and 4 all have some contamination. neg_2_0 seems to be contaminated with HAMBI_1977, neg_3_0 with HAMBI_1287, and neg_4_0 with HAMBI_1977. However in the 5 remaining negative controls there is no contamination.",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#positive-controls",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#positive-controls",
    "title": "Formatting Rbec output",
    "section": "6.2 Positive controls",
    "text": "6.2 Positive controls\nThe positive controls should each have three species. In all cases the species that shouldn’t be there is very rare\n\nfinaltable %&gt;% \n  filter(str_detect(community_type, \"^pos\")) %&gt;%\n  mutate(total_pos_controls = n_distinct(sample)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = round(count_correct/sum(count_correct)*100)) %&gt;%\n  mutate(supposed_2_b_there = if_else(is.na(evo_hist), \"no\", \"yes\")) %&gt;% \n  relocate(f, supposed_2_b_there) %&gt;% \n  distinct(f, supposed_2_b_there, sample, strainID, count_correct, n_species, community_type,)\n\n\n  \n\n\n\nThis is also good - we detect all 3 species that should be there in the positive controls on each plate. In a later step we will use these control samples with metacal to try and correct for the boil prep extraction method.",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#misassigned-reads",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#misassigned-reads",
    "title": "Formatting Rbec output",
    "section": "6.3 Misassigned reads",
    "text": "6.3 Misassigned reads\nThese libraries were only prepared with samples from Milla’s 4-species experiment with 403, 1287, 1896, and 1977 so any time species other than these show up is just an incorrect assignment by Rbec. Let’s check quickly how many of these there are…\n\nfinaltable %&gt;% \n  filter(!str_detect(strainID, \"0403|1287|1896|1977\"))\n\n\n  \n\n\n\nThere is one or two incorrectly assigned reads here and there but this is just noise. We can safely exclude all reads not mapping to one of the focal species.\n\nfinaltable &lt;- finaltable %&gt;% \n  filter(str_detect(strainID, \"0403|1287|1896|1977\"))",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#samples-with-too-few-reads",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#samples-with-too-few-reads",
    "title": "Formatting Rbec output",
    "section": "6.4 Samples with too few reads",
    "text": "6.4 Samples with too few reads\nSome of the experimental pairs had streptomycin concentrations higher than any of the species individually could tolerate. We would naively expect then that neither species would grow successfully in these samples and that the overall biomass would be very low, thus resulting in a low number of recovered reads from these samples.\nTo look into this. first let’s check which samples have very low OD600 in the endpoint samples.\n\nod &lt;- read_tsv(here::here(\"_data_raw\", \"20240606_optical_density\", \"optical_density_formatted.tsv\"))\n\nRows: 2880 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): community_id\ndbl (5): transfers, n_species, strep_conc, replicate, OD\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nfiltids &lt;- finaltable %&gt;% \n  summarize(tot = sum(count_correct), .by = c(sample, community_id, n_species, transfers, strep_conc, replicate)) %&gt;%\n  left_join(od, by = join_by(community_id, n_species, transfers, strep_conc, replicate)) %&gt;% \n  filter(transfers == 8) %&gt;% \n  arrange(tot) %&gt;% \n  arrange(OD) %&gt;% \n  filter(OD &lt; 0.1 | tot &lt; 1000) %&gt;% \n  pull(sample)\n\nWe’ll filter out samples with an OD of less than 0.1 and also samples with fewer than 1000 reads. It is genearlly good practice to exclude samples with low number of reads.\n\nfinaltable &lt;- finaltable %&gt;% \n  filter(sample %nin% filtids)",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#masterplate-samples",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#masterplate-samples",
    "title": "Formatting Rbec output",
    "section": "6.5 Masterplate samples",
    "text": "6.5 Masterplate samples\nTo set up this experiment, Milla combined the species in the planned proportions on a masterplate. Because this process was time consuming, the masterplate was stored at -80C after construction until the experiment start day when it was taken from the freezer and used to inoculate the experiment. Because Milla knows exactly which strains were added to the master plate and the plates were not allowed to grow, any strains in these samples that are not supposed to be there should be due to Illumina index cross talk and not true contamination. We can get a sense for the average index crosstalk rate from these samples and then draw a threshold of when to exclude likely false positives and when a positive is likely due to contamination.\n\nmasterplate &lt;- finaltable %&gt;%\n  filter(community_type == \"masterplate\") %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup()\n\nHere we focus on masterplate samples with species that should not be there. We exclude species that were inoculated and plot the distribution of percentages of those species\n\n\n\n\nmasterplate %&gt;% \n  # here we take advantage of the fact that for species not supposed to be in a sample\n  # the prior left_join will have filled the evo_hist category with an NA. We can then filter\n  # on this NA value\n  filter(is.na(evo_hist)) %&gt;% \n  filter(f &gt; 0) %&gt;% \n  ggplot(aes(x = f)) +\n  geom_histogram(aes(fill = strainID), bins = 20) +\n  geom_vline(xintercept = 0.01, linetype = \"dashed\") +\n  scale_fill_manual(values = hambi_colors) +\n  scale_x_continuous(trans = \"log10\",  labels = percent, guide = guide_axis(angle=90)) + \n  labs(x = \"Crosstalk frequency\", y = \"Count\") +\n  facet_grid(~strainID) + \n  annotation_logticks(sides = \"b\", color=\"grey30\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\nFigure 1: Frequency distribution of each species in masterplate samples where it should not occur. The 1% mark (commonly accepted as an acceptable Illumina cross-talk standard) is demarcated with a dashed line.\n\n\n\nGenerally, the cross talk frequency is pretty OK. For 3/4 species it is 1% or less which is more or less what you can expect when you are multiplexing libraries on an Illumina platform. Values greater than 1% are potentially indicative of a different problem, so 1977 requires a bit more investigation.\n\nsids &lt;- masterplate %&gt;% \n  filter(is.na(evo_hist)) %&gt;% \n  filter(f &gt; 0.01 & strainID == \"HAMBI_1977\") %&gt;% \n  pull(sample) \n\nmasterplate %&gt;% \n  filter(sample %in% sids) %&gt;% \n  dplyr::select(sample, strainID, count_correct, replicate, evo_hist, target_f, f)\n\n\n  \n\n\n\nIt looks like all the “problematic” samples come from plates 7 and 8 in the library prep. Plate 8 only contains the masterplate samples from trios whereas plate 7 contains both masterplate and experimental samples. Figure 2 shows that HAMBI-1977 is very abundant in many of the samples so likely the “leaky” reads come disproportionately from HAMBI-1977 which is why its crosstalk threshold may be higher (Figure 1).\n\n\n\n\nfinaltable %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # here we take advantage of the fact that for species not supposed to be in a sample\n  # the prior left_join will have filled the evo_hist category with an NA. We can then filter\n  # on this NA value\n  filter(!is.na(evo_hist)) %&gt;% \n  filter(f &gt; 0) %&gt;% \n  ggplot(aes(x = f)) +\n  geom_histogram(aes(fill = strainID), bins = 20) +\n  scale_fill_manual(values = hambi_colors) +\n  scale_x_continuous(trans = \"log10\",  labels = percent, guide = guide_axis(angle=90)) + \n  labs(x = \"Frequency in samples\", y = \"Count\") +\n  facet_grid(~strainID) + \n  annotation_logticks(sides = \"b\", color=\"grey30\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\nFigure 2: Frequency distribution of each species in all samples where it should occur.\n\n\n\nAnyway, I don’t think this is a problem and that we can move forward with these samples. However, to define extinction/competitive exclusion we may need to use a higher threshold than 1% (e.g., 3% frequency) because over 3% we can reliably say that a species is present and it is not due to index cross talk.",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#experimental-samples",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#experimental-samples",
    "title": "Formatting Rbec output",
    "section": "6.6 Experimental samples",
    "text": "6.6 Experimental samples\nNow we need to see how our experimental samples performed and if there are species present in them that shouldn’t be there\n\nexp_contam &lt;- finaltable %&gt;% \n  filter(str_detect(community_type, \"experiment\")) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # because we set 3% as our limit of detection we set read counts of species \n  # less than 1% to 0\n  mutate(count_correct_thresh = if_else(f &lt;= 0.03, 0, count_correct)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct_thresh/sum(count_correct_thresh)) %&gt;% \n  ungroup()\n\n\n\n\n\nexp_contam %&gt;% \n  filter(is.na(evo_hist)) %&gt;% \n  ggplot(aes(x = f)) +\n  geom_histogram(aes(fill = strainID), bins = 20) +\n  scale_fill_manual(values = hambi_colors) +\n  scale_x_continuous(trans = \"log10\",  labels = percent, guide = guide_axis(angle=90)) + \n  labs(x = \"Frequency in samples\", y = \"Count\") +\n  facet_grid(~ strainID) + \n  annotation_logticks(sides = \"b\", color=\"grey30\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\")\n\nWarning in scale_x_continuous(trans = \"log10\", labels = percent, guide =\nguide_axis(angle = 90)): log-10 transformation introduced infinite values.\n\n\nWarning: Removed 783 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Frequency distribution of each species in experimental samples where it should not occcur.\n\n\n\nIt’s not too bad… but 72 of 566 samples (12.7%) have probably been contaminated because they contain a species that shouldn’t be in the sample (using the 3% relative abundance as a robust threshold for presence/absence).\n\n6.6.1 Contaminated pairs\nTaking a closer look at specific experimental samples with contamination.\nHere we just select samples that have &gt; 3% of a species that shouldn’t be there and prepare them for plotting.\n\ncontamsampid &lt;- exp_contam %&gt;% \n  filter(f &gt; 0) %&gt;% \n  filter(is.na(evo_hist)) %&gt;% \n  pull(sample)\n\nspcols &lt;- c(\"HAMBI_0403_anc\" = \"#faa019\",\n            \"HAMBI_0403_evo\" = \"#bd7811\",\n            \"HAMBI_1287_anc\" = \"#75afff\",\n            \"HAMBI_1287_evo\" = \"#476c9e\",\n            \"HAMBI_1896_anc\" = \"#59cc4e\",\n            \"HAMBI_1896_evo\" = \"#31752a\",\n            \"HAMBI_1977_anc\" = \"#ffd430\",\n            \"HAMBI_1977_evo\" = \"#ab8e1f\",\n            \n            \"HAMBI_0403_NA\"  = \"#e6e5e3\",\n            \"HAMBI_1287_NA\"  = \"#bdbcbb\",\n            \"HAMBI_1896_NA\"  = \"#8c8c8b\",\n            \"HAMBI_1977_NA\"  = \"#333333\"\n            )\n\nexp_contam_plot &lt;- exp_contam %&gt;%\n  filter(sample %in% contamsampid) %&gt;% \n  mutate(sp = paste0(strainID, \"_\", evo_hist))\n\n\n\n\n\nexp_contam_plot %&gt;% \n  filter(n_species == 2) %&gt;% \n  ggplot() +\n  geom_col(aes(x = sample, y=f, fill = sp)) +\n  facet_wrap( ~ strep_conc, scales = \"free_x\", ncol = 2) +\n  labs(y = \"Abundance\", x = \"\", fill = \"\") +\n  scale_fill_manual(values = spcols) +\n  scale_y_continuous(labels = percent) +\n  scale_x_discrete(guide = guide_axis(angle=90)) +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"right\")\n\n\n\n\n\n\n\n\n\n\nFigure 4: Species composition of pair samples that contain &gt; 3% of a species that shouldn’t be there (shown in grey to black).\n\n\n\nI think pretty much the only way to deal with this is to inspect manually. Most of the comtaminated samples are in the 0 Streptomycin conditions. I think we should exclude samples where the contamination is very high (over ~50% of the sample) but those with 10% or less contaminant I think can be retained, and I will discard the contaminating sequences.\n\nnotcontampairs &lt;- c(\"P04_1_0\", \"P45_2_0\", \"P01_2_64\", \"P03_2_64\", \n                    \"P06_1_256\", \"P17_2_256\", \"P30_1_256\", \"P30_2_256\", \n                    \"P41_2_256\")\n\ncontampairs &lt;- setdiff(contamsampid[grepl(\"^P\", contamsampid)], notcontampairs)\n\n\n\n6.6.2 Contaminated trios\nNow we’ll do the same thing and inspect the trios.\n\n\n\n\nexp_contam_plot %&gt;% \n  filter(n_species == 3) %&gt;% \n  ggplot() +\n  geom_col(aes(x = sample, y=f, fill = sp)) +\n  labs(y = \"Abundance\", x = \"\", fill = \"\") +\n  scale_fill_manual(values = spcols) +\n  scale_y_continuous(labels = percent) +\n  scale_x_discrete(guide = guide_axis(angle=90)) +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"right\")\n\n\n\n\n\n\n\n\n\n\nFigure 5: Species composition of trio samples that contain &gt; 3% of a species that shouldn’t be there (shown in grey to black).\n\n\n\nAgain, I think we should exclude samples where the contamination is very high (over ~50% of the sample) but those with around 10% or less contaminant I think can be retained, and I will discard the contaminating sequences.\n\nnotcontamtrios &lt;- c(\"T01_2_0\", \"T02_2_0\", \"T04_2_0\", \"T05_2_0\", \"T13_2_0\", \n                    \"T14_2_0\", \"T15_1_0\", \"T15_2_0\", \"T16_1_0\", \"T16_2_0\", \n                    \"T17_2_0\", \"T18_2_0\",\"T31_2_0\", \"T45_1_0\", \"T45_2_0\", \n                    \"T55_1_0\", \"T61_1_0\", \"T61_2_0\", \"T64_1_0\", \"T64_2_0\")\n\ncontamtrios &lt;- setdiff(contamsampid[grepl(\"^T\", contamsampid)], notcontamtrios)",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#posneg-control-samples",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#posneg-control-samples",
    "title": "Formatting Rbec output",
    "section": "7.1 pos/neg control samples",
    "text": "7.1 pos/neg control samples\nSeparate out the pos/neg control samples\n\nfinaltable %&gt;% \n  filter(str_detect(community_type, \"^pos|^neg\")) %&gt;% \n  dplyr::select(-transfers, -strep_conc, -evo_hist, -target_f, -count) %&gt;% \n  write_tsv(here::here(data, \"pos_neg_ctrl_counts.tsv\"))",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#pairs",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#pairs",
    "title": "Formatting Rbec output",
    "section": "7.2 Pairs",
    "text": "7.2 Pairs\nseparate, format, and write the pair samples\n\npairs &lt;- finaltable %&gt;% \n  filter(!str_detect(community_type, \"^pos|^neg\")) %&gt;%\n  filter(n_species == 2) %&gt;% \n  filter(sample %nin% contampairs) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # because we set 3% as our limit of detection we set read counts of species \n  # less than 1% to 0\n  mutate(count_correct_thresh = if_else(f &lt;= 0.03, 0, count_correct)) %&gt;% \n  # also exclude any remaining counts from species that shouldnt be there\n  # using again the fact that evo_hist should be NA for these species\n  filter(!is.na(evo_hist)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct_thresh/sum(count_correct_thresh)) %&gt;% \n  ungroup() %&gt;%\n  dplyr::select(sample, strainID, evo_hist, count_correct, count_correct_thresh, \n                f, target_f, replicate, strep_conc, transfers, n_species, community_type, plate_well)\n\nwrite_tsv(pairs, here::here(data, \"pairs_counts.tsv\"))",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#trios",
    "href": "R/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#trios",
    "title": "Formatting Rbec output",
    "section": "7.3 Trios",
    "text": "7.3 Trios\n\ntrios &lt;- finaltable %&gt;% \n  filter(!str_detect(community_type, \"^pos|^neg\")) %&gt;%\n  filter(n_species == 3) %&gt;% \n  filter(sample %nin% contamtrios) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # because we set 3% as our limit of detection we set read counts of species \n  # less than 1% to 0\n  mutate(count_correct_thresh = if_else(f &lt;= 0.03, 0, count_correct)) %&gt;% \n  # also exclude any remaining counts from species that shouldnt be there\n  # using again the fact that evo_hist should be NA for these species\n  filter(!is.na(evo_hist)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct_thresh/sum(count_correct_thresh)) %&gt;% \n  ungroup() %&gt;%\n  dplyr::select(sample, strainID, evo_hist, count_correct, count_correct_thresh, \n                f, target_f, replicate, strep_conc, transfers, n_species, community_type, plate_well)\n\nwrite_tsv(trios, here::here(data, \"trios_counts.tsv\"))",
    "crumbs": [
      "Community composition amplicon",
      "1. 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "",
    "text": "We will use the metacal package for estimating bias and performing calibration in the special case where the bias of all the taxa of interest can be directly measured from the control sample. Since samples extracted by Qiagen and by boil are exactly the same we can estimate scaling factors to produce corrected relative abundance for other samples.\nPublication: Consistent and correctable bias in metagenomic sequencing experiments",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#libraries",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#libraries",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(here)\nlibrary(tidyverse)\nlibrary(metacal)\nlibrary(withr)\nlibrary(scales)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#global-variables",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#global-variables",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240711_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240711_BTK_illumina_v3\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#format-positive-control-samples",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#format-positive-control-samples",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "4.1 Format positive control samples",
    "text": "4.1 Format positive control samples\n\npos_ctrl &lt;- left_join(pos_ctrl, spdf) %&gt;% \n  filter(str_detect(community_type, \"^pos\")) %&gt;%\n  # remove noise from species that aren't really there\n  filter(!is.na(evo_hist)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f_qg = count_correct/sum(count_correct)) %&gt;% \n  dplyr::select(sample, strainID, community_id, count_correct, f_qg) %&gt;% \n  ungroup()\n\nJoining with `by = join_by(strainID, community_id)`",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#plot-masterplate-qiagen-and-boil-prep-side-by-side",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#plot-masterplate-qiagen-and-boil-prep-side-by-side",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "4.2 Plot masterplate Qiagen and boil-prep side by side",
    "text": "4.2 Plot masterplate Qiagen and boil-prep side by side\n\n\n\n\nleft_join(samp_trios, mddf,\n          by = join_by(sample, replicate, strep_conc, transfers, n_species, community_type, plate_well)) %&gt;% \n  filter(community_type == \"masterplate\") %&gt;% \n  right_join(pos_ctrl, by = join_by(strainID, community_id)) %&gt;% \n  dplyr::select(community_id, strainID, f, f_qg) %&gt;% \n  pivot_longer(c(f, f_qg)) %&gt;% \n  ggplot() +\n    geom_bar(aes(y = value, x=interaction(name, community_id), fill = strainID), \n             color=\"black\",\n             linewidth=0.25, stat=\"identity\") +\n    scale_y_continuous(limits = c(0,1), expand = c(0, 0), labels = percent) +\n    scale_x_discrete(guide = guide_axis(angle = 90)) +\n    labs(x=\"\", y=\"% abundance\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\") +\n  scale_fill_manual(values = hambi_colors)\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bar plot of masterplate samples extracted by the boilprep method (f) or the Qiagen DNeasy kit (qg). The community trios are appended to the extraction method on the x axs",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#matrix-of-observed-counts",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#matrix-of-observed-counts",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "4.3 Matrix of observed counts",
    "text": "4.3 Matrix of observed counts\n\nsamp_trios_counts &lt;- left_join(samp_trios, mddf) %&gt;% \n  filter(community_type == \"masterplate\") %&gt;% \n  filter(community_id %in% pull(pos_ctrl, community_id)) %&gt;% \n  dplyr::select(community_id, strainID, count_correct) %&gt;% \n  pivot_wider(names_from=\"strainID\", values_from=\"count_correct\") %&gt;% \n  column_to_rownames(var=\"community_id\") %&gt;% \n  mutate(across(everything(), ~replace_na(.x, 0))) %&gt;% \n  as.matrix()\n\nJoining with `by = join_by(sample, replicate, strep_conc, transfers, n_species,\ncommunity_type, plate_well)`",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#make-a-matrix-of-true-proportions",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#make-a-matrix-of-true-proportions",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "4.4 Make a matrix of true proportions",
    "text": "4.4 Make a matrix of true proportions\n\npos_ctrl_proportions &lt;- pos_ctrl %&gt;% \n  dplyr::select(community_id, strainID, f_qg) %&gt;%\n  pivot_wider(names_from=\"strainID\", values_from=\"f_qg\") %&gt;% \n  column_to_rownames(var=\"community_id\") %&gt;% \n  mutate(across(everything(), ~replace_na(.x, 0))) %&gt;% \n  as.matrix()",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#estimate-bias",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#estimate-bias",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "5.1 Estimate bias",
    "text": "5.1 Estimate bias\n\nset.seed(12378)\nmc_fit_trios &lt;- metacal::estimate_bias(samp_trios_counts, pos_ctrl_proportions, 1, boot=TRUE)\nmc_fit_trios_summary &lt;- summary(mc_fit_trios)\nmc_fit_trios_summary_coef &lt;-mc_fit_trios_summary[['coefficients']]\n\n\n5.1.1 Plot bias estimation\n\n\n\n\nmc_fit_trios_summary_coef %&gt;% \n  mutate(taxon = fct_reorder(taxon, estimate)) |&gt; \n  ggplot(aes(taxon, estimate, \n             ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange(aes(color = taxon)) +\n  scale_color_manual(values = hambi_colors) +\n  labs(x = \"\", y = \"Bias estimate\", color = \"\") +\n  coord_flip() + \n  theme_bw() +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())\n\n\n\n\n\n\n\n\n\n\nFigure 2: Bias estimates for each species from the metacal procedure.\n\n\n\n\n\n5.1.2 Plot metacal model fit\n\na &lt;- as.data.frame(fitted(mc_fit_trios)) %&gt;% \n  rownames_to_column(var = \"sample\") %&gt;% \n  pivot_longer(-sample) %&gt;% \n  mutate(type=\"Fitted\")\n\nb &lt;- as.data.frame(pos_ctrl_proportions) %&gt;% \n  rownames_to_column(var = \"sample\") %&gt;% \n  pivot_longer(-sample) %&gt;% \n  mutate(type=\"Actual\")\n\nc &lt;- as.data.frame(samp_trios_counts/rowSums(samp_trios_counts)) %&gt;% \n  rownames_to_column(var = \"sample\") %&gt;% \n  pivot_longer(-sample,  values_to=\"observed\")\n\n\n\n\n\nbind_rows(a,b) %&gt;% \n  left_join(c) %&gt;% \n  ggplot(aes(x=observed, y=value, color = name)) +\n  geom_abline(linetype = \"dashed\") +\n  geom_point() +\n  scale_color_manual(values = hambi_colors) +\n  labs(x = \"Species proportion in boil-prepped samples\", y = \"Species proportion in Qiagen-prepped samples\", color = \"\") +\n  facet_grid(~type) + \n  coord_fixed(xlim = c(0, 1), ylim = c(0, 1)) + \n  theme_bw() +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())\n\nJoining with `by = join_by(sample, name)`\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Porportion of each species from boil-prepped samples (x-axis) and from the Qiagen DNeasy extracted samples (y-axis) colored by species identity. The left panel shows the relationship between the two extraction procedures before correction with metacal. The right panel shows the relationship after correction. The dashed line is 1:1.",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#calibrate",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#calibrate",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "5.2 Calibrate",
    "text": "5.2 Calibrate\nMake a matrix of observed counts\n\ntrios_2_cal &lt;- left_join(samp_trios, mddf) %&gt;% \n  dplyr::select(sample, strainID, count_correct) %&gt;% \n  pivot_wider(names_from=\"strainID\", values_from=\"count_correct\") %&gt;% \n  column_to_rownames(var=\"sample\") %&gt;% \n  mutate(across(everything(), ~replace_na(.x, 0))) %&gt;%\n  as.matrix()\n\nJoining with `by = join_by(sample, replicate, strep_conc, transfers, n_species,\ncommunity_type, plate_well)`\n\npairs_2_cal &lt;- left_join(samp_pairs, mddf) %&gt;% \n  dplyr::select(sample, strainID, count_correct) %&gt;% \n  pivot_wider(names_from=\"strainID\", values_from=\"count_correct\") %&gt;% \n  column_to_rownames(var=\"sample\") %&gt;% \n  mutate(across(everything(), ~replace_na(.x, 0))) %&gt;%\n  as.matrix()\n\nJoining with `by = join_by(sample, replicate, strep_conc, transfers, n_species,\ncommunity_type, plate_well)`",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#run-the-calibrate-function",
    "href": "R/amplicon/20240711_BTK_illumina_v3/02_correct_boil_to_qiagen.html#run-the-calibrate-function",
    "title": "Calibrate boilprep to Qiagen DNeasy",
    "section": "5.3 Run the calibrate function",
    "text": "5.3 Run the calibrate function\n\nset.seed(435761)\n\npairs_calibrated &lt;- metacal::calibrate(pairs_2_cal, coef(mc_fit_trios), margin=1)\ntrios_calibrated &lt;- metacal::calibrate(trios_2_cal, coef(mc_fit_trios), margin=1)\n\n\npairs_calibrated_l &lt;- data.frame(pairs_calibrated) %&gt;% \n  rownames_to_column(var = \"sample\") %&gt;% \n  pivot_longer(-sample, names_to = \"strainID\", values_to = \"f_metacal\") %&gt;% \n  filter(f_metacal &gt; 0)\n\ntrios_calibrated_l &lt;- data.frame(trios_calibrated) %&gt;% \n  rownames_to_column(var = \"sample\") %&gt;% \n  pivot_longer(-sample, names_to = \"strainID\", values_to = \"f_metacal\") %&gt;% \n  filter(f_metacal &gt; 0)",
    "crumbs": [
      "Community composition amplicon",
      "2.  20240711 BTK Illumina v3 / Metacal calibration"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html",
    "href": "R/experiment_design/02_trios.html",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)\n\n\n\n\n\ndata &lt;- here::here(\"data\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\nSpecies color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#libraries",
    "href": "R/experiment_design/02_trios.html#libraries",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#functions-and-vars",
    "href": "R/experiment_design/02_trios.html#functions-and-vars",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "Species color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#first-pipetting-step",
    "href": "R/experiment_design/02_trios.html#first-pipetting-step",
    "title": "Designing three-species subcommunities",
    "section": "3.1 First pipetting step",
    "text": "3.1 First pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Layout for the first pipetting step for constructing trios Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 80% (e.g., _80) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#second-pipetting-step",
    "href": "R/experiment_design/02_trios.html#second-pipetting-step",
    "title": "Designing three-species subcommunities",
    "section": "3.2 Second pipetting step",
    "text": "3.2 Second pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Layout for the second pipetting step for constructing trios Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 80% (e.g., _80) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#third-pipetting-step",
    "href": "R/experiment_design/02_trios.html#third-pipetting-step",
    "title": "Designing three-species subcommunities",
    "section": "3.3 Third pipetting step",
    "text": "3.3 Third pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Layout for the third pipetting step for constructing trios Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 80% (e.g., _80) or 10% (e.g., _10).",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html",
    "href": "R/amplicon/analysis_pairs.html",
    "title": "Analysis of pairwise competition",
    "section": "",
    "text": "Contains results from pairs of all streptomycin concentrations and trios for 0 streptomycin from Milla’s bottom up community assembly experiment",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#libraries",
    "href": "R/amplicon/analysis_pairs.html#libraries",
    "title": "Analysis of pairwise competition",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(patchwork)\nlibrary(broom)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#global-variables",
    "href": "R/amplicon/analysis_pairs.html#global-variables",
    "title": "Analysis of pairwise competition",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240711_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240711_BTK_illumina_v3\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#metadata",
    "href": "R/amplicon/analysis_pairs.html#metadata",
    "title": "Analysis of pairwise competition",
    "section": "3.1 Metadata",
    "text": "3.1 Metadata\n\nmddf &lt;- readr::read_tsv(here::here(data_raw, \"20240711_BTK_illumina_v3_metadata.tsv\"))\nspdf &lt;- readr::read_tsv(here::here(data_raw, \"sample_compositions.tsv\"))",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#species-abundances",
    "href": "R/amplicon/analysis_pairs.html#species-abundances",
    "title": "Analysis of pairwise competition",
    "section": "3.2 Species abundances",
    "text": "3.2 Species abundances\n\nsamp_pairs &lt;- readr::read_tsv(here::here(data, \"pairs_counts.tsv\"))\n#samp_trios &lt;- readr::read_tsv(here::here(data, \"trios_counts.tsv\"))\n\nsamp_pairs_cal &lt;- readr::read_tsv(here::here(data, \"pairs_metacal.tsv\"))\n#samp_trios_cal &lt;- readr::read_tsv(here::here(data, \"trios_metacal.tsv\"))",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#transfer-0-starting-proportions",
    "href": "R/amplicon/analysis_pairs.html#transfer-0-starting-proportions",
    "title": "Analysis of pairwise competition",
    "section": "4.1 Transfer 0 (starting proportions)",
    "text": "4.1 Transfer 0 (starting proportions)\nFirst get abundances from transfer 0 (masterplate)\n\nsamp_pairs_fmt_mp &lt;- samp_pairs %&gt;% \n  dplyr::filter(community_type == \"masterplate\") %&gt;% \n  # make a combined evolution and species identifier and extract the community ID\n  dplyr::mutate(sp = paste(str_to_upper(evo_hist), str_extract(strainID, \"\\\\d+\"), sep = \"_\"),\n         community_id = str_extract(sample, \"P\\\\d\\\\d\")) %&gt;%\n  # this step is important to ensure that when dfs are pivoted wider the \n  # sp_1 and sp_2 stay consistent \n  dplyr::arrange(community_id, sp) %&gt;%\n  # this creates an index for each species present in each community, it is needed\n  # for the pivot to be consistent between the master plate and the samples\n  dplyr::group_by(community_id) %&gt;% \n  dplyr::mutate(n = 1:n()) %&gt;% \n  dplyr::ungroup() %&gt;% \n  tidyr::pivot_wider(id_cols = community_id, values_from = c(sp, f), names_from = n) %&gt;% \n  dplyr::mutate(transfer = 0) %&gt;% \n  tidyr::expand_grid(strep_conc = c(0, 16, 64, 256))",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#transfer-8-ending-proportions",
    "href": "R/amplicon/analysis_pairs.html#transfer-8-ending-proportions",
    "title": "Analysis of pairwise competition",
    "section": "4.2 Transfer 8 (ending proportions)",
    "text": "4.2 Transfer 8 (ending proportions)\nFormat abundances from the experiment, summarizing over replicates. Here we calculate the median frequency across biological replicates using Hmisc::smedian.hilow which computes the sample median and the outer quantiles (0.025 and 0.975).\n\nsamp_pairs_fmt_exp &lt;- samp_pairs %&gt;% \n  dplyr::filter(community_type == \"experiment\") %&gt;% \n  # make a combined evolution and species identifier and extract the community ID\n  dplyr::mutate(sp = paste(str_to_upper(evo_hist), str_extract(strainID, \"\\\\d+\"), sep = \"_\"),\n         community_id = str_extract(sample, \"P\\\\d\\\\d\")) %&gt;%\n  # calculate median and 95% CI across replicates\n  dplyr::summarize(ggplot2::median_hilow(f), .by = c(\"community_id\", \"sp\", \"strep_conc\")) %&gt;% \n  # rename the y columns as f for compatibility\n  dplyr::rename_with(.cols = starts_with(\"y\"), \\(x) str_replace(x, \"y\", \"f\")) %&gt;% \n  # this step is important to ensure that when dfs are pivoted wider the \n  # sp_1 and sp_2 stay consistent \n  dplyr::arrange(community_id, sp, strep_conc) %&gt;%\n  # this creates an index for each species present in each community, it is needed\n  # for the pivot to be consistent between the master plate and the samples\n  dplyr::group_by(community_id, strep_conc) %&gt;% \n  dplyr::mutate(n = 1:n()) %&gt;% \n  dplyr::ungroup() %&gt;% \n  tidyr::pivot_wider(id_cols = c(community_id, strep_conc), values_from = c(sp, f, fmin, fmax), names_from = n) %&gt;% \n  dplyr::mutate(transfer = 8)",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#binomial-sampling-and-wilcox-test",
    "href": "R/amplicon/analysis_pairs.html#binomial-sampling-and-wilcox-test",
    "title": "Analysis of pairwise competition",
    "section": "5.1 Binomial sampling and Wilcox test",
    "text": "5.1 Binomial sampling and Wilcox test\nFirst need to determine which samples significantly decreased/increased from T0 to T8. We don’t have enough biological replicates for to compute a statistic across replicates for outcome variability. However, we can estimate the mean fraction of A and quantify the inferential uncertainty of the mean by bootstrap resampling. We the used median proportion of species A from two biological replicates of each T8 pair as the probability of success (i.e., drawing species A) from 1000 draws (i.e., sequencing reads) from the binomial distribution. To determine whether the frequency of Species A significantly changed from T0 to T8, the means of the 1000 binomial draws for T0 and T8 were compared using a Wilcoxon rank sum test (N = 2000). Tests with Bonferroni multiple test corrected p values &lt; 1e-5 were considered to represent significantly different T0 and T8 samples.\n\nset.seed(124341)\n\n# first join the T0 and T8 abundances\nwc_test &lt;- left_join(samp_pairs_fmt_exp, samp_pairs_fmt_mp, by = join_by(community_id, strep_conc, sp_1, sp_2)) %&gt;% \n  dplyr::mutate(delta_f_1 = f_1.x - f_1.y) %&gt;% \n  dplyr::select(community_id, strep_conc, sp_1, sp_2, delta_f_1, f_1_8 = f_1.x, f_1_0 = f_1.y, \n                f_2_8 = f_2.x, f_2_0 = f_2.y) %&gt;% \n  tidyr::nest(data = c(-community_id, -strep_conc)) %&gt;%\n  # samples 1000 draws from binomial distribution using f_a median as the probability of success\n  dplyr::mutate(f_1_0_rs = purrr::map(data, \\(x) map(1:100, \\(i) sum(rbinom(1000, 1, x$f_1_0))/1000)),\n         f_1_8_rs = purrr::map(data, \\(x) map(1:100, \\(i) sum(rbinom(1000, 1, x$f_1_8))/1000))) %&gt;% \n  tidyr::unnest(cols = c(data, f_1_0_rs, f_1_8_rs)) %&gt;% \n  # nest the samples\n  tidyr::nest(bs = c(f_1_0_rs, f_1_8_rs)) %&gt;%\n  # perform the wilcox test\n  dplyr::mutate(wc = purrr::map(bs, \\(i) wilcox.test(x = as.numeric(i$f_1_0_rs), y = as.numeric(i$f_1_8_rs)))) %&gt;% \n  # tidy-ify the test output\n  dplyr::mutate(tidy_wc = purrr::map(wc, \\(x) broom::tidy(x))) %&gt;% \n  tidyr::unnest(cols = c(tidy_wc)) %&gt;% \n  # p-value adjust using bonferroni correction\n  dplyr::mutate(p_adjusted = p.adjust(p.value, method = \"bonferroni\", n = n())) %&gt;% \n  dplyr::arrange(strep_conc, sp_1, sp_2) %&gt;% \n  # define whether change is significantly positive or negative\n  dplyr::mutate(change = dplyr::case_when(p.value &gt; 1e-5 ~ 0,\n                             sign(delta_f_1) == -1 & p.value &lt;= 1e-5 ~ -1, \n                             sign(delta_f_1) == 1 & p.value &lt;= 1e-5 ~ 1))",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#competition-outcome-rules",
    "href": "R/amplicon/analysis_pairs.html#competition-outcome-rules",
    "title": "Analysis of pairwise competition",
    "section": "5.2 Competition outcome rules",
    "text": "5.2 Competition outcome rules\nHere we set up the rules for defining the competition outcomes.\nNeed to write these down formally instead of just in the case_when statement…\n\n# upper threshold for deciding whether a species goes extinct\nupper &lt;- 0.99\n# lower threshold for deciding whether a species goes extinct\nlower &lt;- 0.01\n# slope change threshold for deciding whether change from T0 to T8 is important (e.g. requires at least a 5% change of the focal species) \nslope_thresh &lt;- 0.05\n\noutcomes_classified &lt;- wc_test %&gt;% \n  dplyr::group_by(strep_conc, sp_1, sp_2) %&gt;% \n  dplyr::mutate(outcome = dplyr::case_when(# Bistability: Requires sp_1 to both increase from T0 high freq and decrease from T0 low freq\n                             sum(change &lt; 0 & f_1_0 == min(f_1_0), change &gt; 0 & f_1_0 == max(f_1_0)) == 2 ~ \"bistable_stable\",\n                             # Exclusion: sp_1 increases from both low and high T0 freqs and T8 freq is &gt; than the T0 high freq\n                             sum(change) == 2 & f_1_8 &gt;= upper & abs(delta_f_1) &gt; slope_thresh ~ \"exclusion_stable\", \n                             # Exclusion: sp_1 decreases from both low and high T0 freqs and T8 freq is &lt; than the T0 low freq\n                             sum(change) == -2 & f_1_8 &lt;= lower & abs(delta_f_1) &gt; slope_thresh ~ \"exclusion_stable\",\n                             # Coexistence: sp_1 significantly increases from rare and significantly decreases from abundant\n                             sum(change) == 0 & dplyr::if_else(f_1_0 == pmin(f_1_0, f_2_0), f_1_8 &gt; f_1_0, f_1_8 &lt; f_1_0) ~ \"coexistence_stable\",\n                             # Incomplete coexistence: sp_1 is found within extinction thresholds in both experiments, but no condition is\n                             # placed on the significance of the change from T0 to T8\n                             sum(dplyr::between(f_1_8, lower, upper)) == 2 ~ \"coexistence_incomplete\",\n                             # Incomplete exclusion: sp_1 is outside of the extinction threshold (extinct) for at least one sample and within the the \n                             # threshold for the other sample.\n                             sum(!dplyr::between(f_1_8, lower, upper)) == 1 & sum(dplyr::between(f_1_8, lower, upper)) == 1 ~ \"exclusion_incomplete\",\n                             # Inconclusive: samples failing to meet any of the above rules\n                             TRUE ~ \"inconclusive_\")) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::mutate(type = dplyr::if_else(stringr::str_detect(outcome, \"incomplete\"), \"incomplete\", \"stable\"),\n         outcome = stringr::str_extract(outcome, \"(^.+)_.*\", group = 1)) %&gt;% \n  dplyr::relocate(outcome, type, change)",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#plotting-pairwise-outpcomes",
    "href": "R/amplicon/analysis_pairs.html#plotting-pairwise-outpcomes",
    "title": "Analysis of pairwise competition",
    "section": "5.3 Plotting pairwise outpcomes",
    "text": "5.3 Plotting pairwise outpcomes\nConstruct final dataframe to be used for plotting\n\nsamp_pairs_fmt &lt;- dplyr::bind_rows(samp_pairs_fmt_mp, samp_pairs_fmt_exp) %&gt;%\n  dplyr::mutate(\n    group = interaction(community_id, strep_conc),\n    evo_group = dplyr::case_when(\n      dplyr::if_all(c(sp_1, sp_2), \\(x) stringr::str_detect(x, \"ANC\")) ~ \"both_anc\",\n      dplyr::if_all(c(sp_1, sp_2), \\(x) stringr::str_detect(x, \"EVO\")) ~ \"both_evo\",\n      TRUE ~ \"mix\"\n    )\n  ) %&gt;%\n  dplyr::left_join(outcomes_classified,\n                   by = dplyr::join_by(community_id, sp_1, sp_2, strep_conc)) %&gt;%\n  dplyr::mutate(\n    outcome = factor(outcome, levels = c(\"exclusion\", \"coexistence\", \n                                         \"bistable\", \"inconclusive\")),\n    type = factor(type, levels = c(\"stable\", \"incomplete\"))\n  )\n\nPlotting function and colors/linetypes\n\noutcome_pal &lt;- c(\"exclusion\" = \"#800020\", \"coexistence\" = \"#0659bf\", \"inconclusive\" = \"#7c26c7\", \"bistable\" = \"#098f07\")\n\ntype_pal &lt;- c(\"stable\" = \"solid\", \"incomplete\" = \"dashed\", \"potential\" = \"dotted\")\n\npair_plot &lt;- function(df){\n  pj &lt;- ggplot2::position_jitterdodge(jitter.width=0.0,\n                           jitter.height = 0.0,\n                           dodge.width = 0.5,\n                           seed=9)\n  \n  ggplot2::ggplot(df, aes(x = transfer, y = f_1, group = group)) +\n  ggplot2::geom_hline(yintercept = 0, lty = 2, color = \"grey70\") +\n  ggplot2::geom_hline(yintercept = 0.5, lty = 3, color = \"grey70\") +\n  ggplot2::geom_hline(yintercept = 1, lty = 2, color = \"grey70\") +\n  ggplot2::geom_linerange(aes(ymin = fmin_1, ymax = fmax_1, color = outcome), position = pj) +\n  ggh4x::geom_pointpath(aes(color = outcome, linetype = type), position = pj, mult = 0.2) +\n  ggplot2::scale_color_manual(values = outcome_pal) +\n  ggplot2::scale_linetype_manual(values = type_pal) +\n  ggplot2::facet_grid(sp_1 ~ sp_2) +\n  ggplot2::scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1), labels = percent) +\n  ggplot2::scale_x_continuous(breaks = c(0, 8)) +\n  ggplot2::labs(x = \"\", y = \"\", color = \"\") +\n  ggplot2::theme_bw() + \n  ggplot2::theme(panel.grid = element_blank(),\n        strip.background = element_blank(),\n        legend.position = \"none\", \n        panel.border = element_blank(),\n        axis.text = element_text(size = 8),\n        strip.text = element_text(size = 8))\n}\n\nCreate different lists of plots for the mixed (i.e. evo competed against anc) conditions\n\nsamp_pairs_fmt_plots_split_a &lt;- samp_pairs_fmt %&gt;% \n  dplyr::filter(evo_group != \"mix\") %&gt;% \n  dplyr::group_by(strep_conc, evo_group) %&gt;% \n  dplyr::group_split() %&gt;% \n  purrr::map(pair_plot)\n\nsamp_pairs_fmt_plots_split_b &lt;- samp_pairs_fmt %&gt;% \n  dplyr::filter(evo_group == \"mix\") %&gt;% \n  dplyr::group_by(strep_conc) %&gt;% \n  dplyr::group_split() %&gt;% \n  purrr::map(pair_plot)\n\n\nfig01 &lt;- patchwork::wrap_plots(samp_pairs_fmt_plots_split_a, ncol = 2) +\n  patchwork::plot_annotation(tag_levels = \"A\")\n\nggsave(\n  here::here(\"figs\", \"coexistence_pairs.svg\"),\n  fig01,\n  width = 7,\n  height = 12,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggsave(\n  here::here(\"figs\", \"coexistence_pairs.png\"),\n  fig01,\n  width = 7,\n  height = 12,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Outcomes from pairwise cocultures of ancestral (left, A:G) and streptomycin adapted (right, B:H) 0403, 1287, 1896 and 1977 species. Rows in the grid represent differen streptomycin concentrations applied (A:B = 0 µg/ml, C:D = 16 µg/ml, E:F = 64 µg/ml, G:H = 256 µg/ml). Using the rules defined above, red lines show cocultures resulting in exclusion of one of the species, blue lines show cocultures that resulted in coexistence, and purple lines represent inconclusive outcomes due to lack of data or exception to therules. Solid lines show a “definite” outcome and dashed lines show a potentially “incomplete” outcome. Two solid lines of the same color indicate stable coexistence or stable exclusion, a solid and dashed line indicate incomplete coexistence/exclusion, while two dashed lines indicates coexistence without evidence of mutual invasibility. Note some statistical noise has been applied to point positions to prevent overlaps in the plot and aid in visualization.\n\n\n\n\nfig02 &lt;- patchwork::wrap_plots(samp_pairs_fmt_plots_split_b, ncol = 2) +\n  patchwork::plot_annotation(tag_levels = \"A\")\n\nggsave(\n  here::here(\"figs\", \"coexistence_pairs_mixed_hist.svg\"),\n  fig02,\n  width = 7,\n  height = 7,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggsave(\n  here::here(\"figs\", \"coexistence_pairs_mixed_hist.png\"),\n  fig02,\n  width = 7,\n  height = 7,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Results from co-cultures of mixed ancestal and evolved combinations. Line colors and types are as in Figure 1, with the addition of green showing bistability (i.e., Species A and Species B exclude each other when invading from high abundance, and each are excluded by the other when invading from low abundance).",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#functions-for-formatting-and-plotting",
    "href": "R/amplicon/analysis_pairs.html#functions-for-formatting-and-plotting",
    "title": "Analysis of pairwise competition",
    "section": "6.1 Functions for formatting and plotting",
    "text": "6.1 Functions for formatting and plotting\n\nmake_pairs &lt;- function(pairs_df, sp){\n  pairs_df %&gt;%\n    dplyr::filter(transfer == 8) %&gt;%\n    dplyr::distinct(evo_group, strep_conc, sp_1, sp_2) %&gt;%\n    dplyr::group_by(evo_group, strep_conc) %&gt;%\n    dplyr::count( {{ sp }} ) %&gt;% \n    dplyr::rename(sp = {{ sp }} ) %&gt;% \n    dplyr::ungroup()\n}\n\nmake_nodes &lt;- function(pairs_df, ...){\n  sp_1 &lt;- make_pairs(pairs_df, sp_1)\n  sp_2 &lt;- make_pairs(pairs_df, sp_2)\n  \n  total_games &lt;- bind_rows(sp_1, sp_2) %&gt;%\n    dplyr::summarize(games = sum(n),\n              .by = c(sp, ...))\n  \n  win_games &lt;- pairs_df %&gt;%\n    dplyr::filter(transfer == 8) %&gt;%\n    dplyr::filter(outcome == \"exclusion\") %&gt;%\n    dplyr::group_by(sp_1, sp_2, ...) %&gt;%\n    dplyr::mutate(win = case_when(f_1 &gt;= f_2 ~ sp_1, f_2 &gt; f_1 ~ sp_2)) %&gt;%\n    dplyr::ungroup() %&gt;%\n    dplyr::distinct(sp_1, sp_2, win, ...) %&gt;%\n    dplyr::group_by(...) %&gt;%\n    dplyr::count(win, name = \"wins\") %&gt;%\n    dplyr::rename(sp = win) %&gt;%\n    dplyr::ungroup()\n  \n  lose_games &lt;- pairs_df %&gt;%\n    dplyr::filter(transfer == 8) %&gt;%\n    dplyr::filter(outcome == \"exclusion\") %&gt;%\n    dplyr::group_by(sp_1, sp_2, ...) %&gt;%\n    dplyr::mutate(loss = case_when(f_1 &gt;= f_2 ~ sp_2, f_2 &gt; f_1 ~ sp_1)) %&gt;%\n    dplyr::ungroup() %&gt;%\n    dplyr::distinct(sp_1, sp_2, loss, ...) %&gt;%\n    dplyr::group_by(...) %&gt;%\n    dplyr::count(loss, name = \"losses\") %&gt;%\n    dplyr::rename(sp = loss) %&gt;%\n    dplyr::ungroup()\n  \nleft_join(total_games, win_games, by = join_by(sp, ...)) %&gt;% \n  dplyr::left_join(lose_games, by = join_by(sp, ...)) %&gt;% \n  dplyr::mutate(across(everything(), ~replace_na(.x, 0))) %&gt;% \n  dplyr::mutate(score = (wins - losses)/games) %&gt;% \n  dplyr::group_by(...) %&gt;% \n  dplyr::arrange(..., desc(score)) %&gt;% \n  dplyr::mutate(rank = dense_rank(desc(score)),\n         plotrank = row_number(desc(score)),\n         id = 1:n()) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::select(name = sp, ..., rank, plotrank)\n}\n\nmake_edges &lt;- function(pairs_df, ...){\n  pairs_df %&gt;% \n    dplyr::filter(transfer == 8) %&gt;% \n    dplyr::mutate(from = if_else(f_1 &gt; f_2, sp_1, sp_2),\n           to = if_else(f_1 &lt; f_2, sp_1, sp_2)) %&gt;% \n    dplyr::group_by(from, to, ...) %&gt;% \n    dplyr::mutate(type = if_else(sum(type == \"stable\") == 2, \"stable\", \"incomplete\")) %&gt;% \n    dplyr::ungroup() %&gt;% \n    dplyr::select(from, to, ..., outcome, type) %&gt;% \n    dplyr::distinct() %&gt;% \n    dplyr::arrange(from, to, ...)\n}\n\nplot_network_hierarchy &lt;- function(net, tune_angle = 1, n_rank = 10, n_break = 10) {\n  # code for formatting the positions of the nodes with the ranks was taken from\n  # here: https://github.com/Chang-Yu-Chang/emergent-coexistence/blob/v2.0.0/plotting_scripts/Fig3.R\n  \n  node_size &lt;- 3\n  edge_width &lt;- 0.8\n\n  graph_ranked &lt;- net %&gt;%\n    tidygraph::activate(nodes) %&gt;%\n    dplyr::select(name, rank, plotrank) %&gt;%\n    tidygraph::activate(edges) %&gt;%\n    dplyr::mutate(fromRank = .N()$plotrank[match(from, .N()$name)],\n           toRank = .N()$plotrank[match(to, .N()$name)])\n\n  graph_ranked &lt;- graph_ranked %&gt;%\n    tidygraph::activate(nodes) %&gt;%\n    dplyr::mutate(y = -rank) %&gt;%\n    dplyr::group_by(rank) %&gt;%\n    dplyr::mutate(x = {seq(0, 1, length.out = n() + 2) %&gt;% `[`(c(-1, -length(.)))}) %&gt;%\n    dplyr::ungroup() %&gt;%\n    tidygraph::activate(edges) %&gt;%\n    dplyr::filter(!str_detect(outcome, \"inconclusive\")) %&gt;%\n    dplyr::arrange(outcome)\n\n  ggraph(graph_ranked, layout = \"nicely\") +\n    geom_hline(yintercept = c(-n_rank:-1), color = \"grey90\") +\n    geom_node_text(aes(label = name), repel = TRUE) +\n    geom_node_point(size = node_size, shape = 21, fill = \"grey\", stroke = node_size/5, color = \"black\") +\n    geom_edge_diagonal(aes(color = outcome, linetype = type),\n                       arrow = arrow(length = unit(1, \"mm\"), type = \"closed\", angle = 30, ends = \"last\"),\n                       start_cap = circle(node_size*.8, \"mm\"),\n                       end_cap = circle(node_size*0.8, \"mm\")) +\n    scale_edge_color_manual(values = outcome_pal) +\n    scale_edge_linetype_manual(values = type_pal) +\n    scale_x_continuous(limits = c(0.1, 0.9), expand = c(0,0)) +\n    scale_y_continuous(limits = c(-n_break-1, 0), breaks = -n_break:-1, labels = n_break:1) +\n    theme_void() +\n    theme(\n        legend.title = element_blank(),\n        axis.title = element_blank(),\n        strip.text = element_blank(),\n        plot.margin = unit(c(0,0,0,0),\"mm\")\n    )\n}",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#evolution-and-streptomycin-categories-separate",
    "href": "R/amplicon/analysis_pairs.html#evolution-and-streptomycin-categories-separate",
    "title": "Analysis of pairwise competition",
    "section": "6.2 Evolution and Streptomycin categories separate",
    "text": "6.2 Evolution and Streptomycin categories separate\nHere we plot a separate graph for each streptomycin concentrations and also by different evolutionary groupings. For example, there is one graph for the competition outcomes of only ancestral species, there is one graph of the outcomes of only evolved species, and there is one graph for the outcomes of mixed competitions where an ancestral species competes against an evolved species.\n\nnodes1 &lt;- make_nodes(samp_pairs_fmt, evo_group, strep_conc)\nedges1 &lt;- make_edges(samp_pairs_fmt, evo_group, strep_conc)\n\ngraphs1 &lt;- nest(nodes1, sps = -c(evo_group, strep_conc)) %&gt;% \n  left_join(nest(edges1, pairs = -c(evo_group, strep_conc)),\n            by = join_by(evo_group, strep_conc)) %&gt;% \n  mutate(network = map2(sps, pairs, function(sps, pairs) tbl_graph(nodes = sps, edges = pairs, directed = T))) %&gt;% \n  mutate(plot = map(network, function(network) plot_network_hierarchy(network, tune_angle = 1.5, n_rank = 7, n_break = 7)))\n\n\nfig03 &lt;- patchwork::wrap_plots(graphs1[[6]], nrow = 3, guides= \"collect\") +\n  patchwork::plot_annotation(tag_levels = \"A\")\n\nggsave(\n  here::here(\"figs\", \"coexistence_networks_nested_evo_strep.svg\"),\n  fig03,\n  width = 8,\n  height = 10,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggsave(\n  here::here(\"figs\", \"coexistence_networks_nested_evo_strep.png\"),\n  fig03,\n  width = 8,\n  height = 10,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Competitive hierarchy of species pairs separated by evolution grouping (only ancestral pairs, only evolved pairs, and mixed ancestral and evolved pairs) and streptomycin concentration. Subplots A-D are for only ancestral pairs, E-H for only evolved pairs, and I-L for mixed ancestral and evolved pairs. Subplots A, E, I show experiments under no streptomycin, B, F, J 16 µg/ml streptomycin, C, G, K for 64 µg/ml streptomycin, and D, H, L for 256 µg/ml streptomycin. For each evolution/streptomycin grouping, strains are rank ordered on the basis of the number of other strains they exclude, based on data shown in Figure 1 and Figure 2. Grey nodes represent strains (denoted by text), red arrows point from winning strain to losing strain, blue arrows indicate coexistence (ignore the arrow heads for blue, coulnd’t figure out how to remove them for only a subset of the edges), and green arrows indicate the presence of bistability (i.e., Species A and Species B exclude each other when invading from high abundance, and each are excluded by the other when invading from low abundance). Line type indicates the degree of certainty of the outcome in each pair: dashed lines represent incomplete exclusion or coexistence without evidence of mutual invasibility, while solid lines indicate complete exclusion or stable coexistence (mutual invasibility).",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/amplicon/analysis_pairs.html#only-streptomycin-category-separate",
    "href": "R/amplicon/analysis_pairs.html#only-streptomycin-category-separate",
    "title": "Analysis of pairwise competition",
    "section": "6.3 Only Streptomycin category separate",
    "text": "6.3 Only Streptomycin category separate\n\nnodes2 &lt;- make_nodes(samp_pairs_fmt, strep_conc)\nedges2 &lt;- make_edges(samp_pairs_fmt, strep_conc)\n\ngraphs2 &lt;- nest(nodes2, sps = -c(strep_conc)) %&gt;% \n  left_join(nest(edges2, pairs = -c(strep_conc)),\n            by = join_by(strep_conc)) %&gt;% \n  mutate(network = map2(sps, pairs, function(sps, pairs) tbl_graph(nodes = sps, edges = pairs, directed = T))) %&gt;% \n  mutate(plot = map(network, function(network) plot_network_hierarchy(network, tune_angle = 1.5, n_rank = 7, n_break = 7)))\n\n\nfig04 &lt;- patchwork::wrap_plots(graphs2[[5]], nrow = 1, guides= \"collect\") +\n  patchwork::plot_annotation(tag_levels = \"A\")\n\nggsave(\n  here::here(\"figs\", \"coexistence_networks_nested_strep.svg\"),\n  fig04,\n  width = 9,\n  height = 4,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggsave(\n  here::here(\"figs\", \"coexistence_networks_nested_strep.png\"),\n  fig04,\n  width = 9,\n  height = 4,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Competitive hierarchy of species pairs separated by streptomycin concentration. Subplot A shows experiments under no streptomycin, B with 16 µg/ml streptomycin, C with 64 µg/ml streptomycin, and D with 256 µg/ml streptomycin. For each evolution/streptomycin grouping, strains are rank ordered on the basis of the number of other strains they exclude, based on data shown in Figure 1 and Figure 2. Grey nodes represent strains (denoted by text), red arrows point from winning strain to losing strain, blue arrows indicate coexistence (ignore the arrow heads for blue, coulnd’t figure out how to remove them for only a subset of the edges), and green arrows indicate the presence of bistability (i.e., Species A and Species B exclude each other when invading from high abundance, and each are excluded by the other when invading from low abundance). Line type indicates the degree of certainty of the outcome in each pair: dashed lines represent incomplete exclusion or coexistence without evidence of mutual invasibility, while solid lines indicate complete exclusion or stable coexistence (mutual invasibility).",
    "crumbs": [
      "Community composition amplicon",
      "3. Species pairs analysis"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html#global-variables",
    "href": "R/experiment_design/01_pairs.html#global-variables",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "data &lt;- here::here(\"data\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/experiment_design/01_pairs.html#format-and-save",
    "href": "R/experiment_design/01_pairs.html#format-and-save",
    "title": "Designing two-species subcommunities",
    "section": "2.1 Format and save",
    "text": "2.1 Format and save\n\ncombos02_filt_well %&gt;%\n  group_by(a, b) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3)) %&gt;% \n  arrange(well) %&gt;% \n  dplyr::select(microcosm_id, well, a, a_sp, a_f, b, b_sp, b_f) %&gt;% \n  readr::write_tsv(here::here(data, \"pairs_sample_composition_wide.tsv\"))\n\n\ncombos02_filt_well %&gt;% \n  group_by(a, b) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  dplyr::select(a:b, well, microcosm_id) %&gt;% \n  tidyr::pivot_longer(c(-well, -microcosm_id)) %&gt;% \n  tidyr::separate(value, c(\"evo_hist\", \"strainID\", \"target_f\")) %&gt;% \n  dplyr::mutate(evo_hist = stringr::str_to_lower(evo_hist),\n                strainID = paste0(\"HAMBI_\", strainID),\n                target_f = as.numeric(target_f)/100,\n                n_species = 2) %&gt;% \n  dplyr::select(-name) %&gt;% \n  dplyr::relocate(microcosm_id, n_species) %&gt;% \n  readr::write_tsv(here::here(data, \"pairs_sample_composition_long.tsv\"))",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "1. Species pairs"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#global-variables",
    "href": "R/experiment_design/03_quartets.html#global-variables",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "data &lt;- here::here(\"data\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/03_quartets.html#format-and-save",
    "href": "R/experiment_design/03_quartets.html#format-and-save",
    "title": "Designing four-species subcommunities",
    "section": "2.1 Format and save",
    "text": "2.1 Format and save\n\ncombos04_filt_wells %&gt;%\n  group_by(a, b, c, d) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         c_sp = paste0(str_split_i(c, \"_\", 2), stringr::str_extract(str_split_i(c, \"_\", 1), \"^.{1}\")),\n         d_sp = paste0(str_split_i(d, \"_\", 2), stringr::str_extract(str_split_i(d, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3),\n         c_f = str_split_i(c, \"_\", 3),\n         d_f = str_split_i(d, \"_\", 3)) %&gt;% \n  arrange(well) %&gt;% \n  dplyr::select(microcosm_id, well, a, a_sp, a_f, b, b_sp, b_f, c, c_sp, c_f, d, d_sp, d_f) %&gt;% \n  readr::write_tsv(here::here(data, \"quartets_sample_composition_wide.tsv\"))\n\n\ncombos04_filt_wells %&gt;%\n  group_by(a, b, c, d) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  dplyr::select(a:d, well, microcosm_id) %&gt;% \n  tidyr::pivot_longer(c(-well, -microcosm_id)) %&gt;% \n  tidyr::separate(value, c(\"evo_hist\", \"strainID\", \"target_f\")) %&gt;% \n  dplyr::mutate(evo_hist = stringr::str_to_lower(evo_hist),\n                strainID = paste0(\"HAMBI_\", strainID),\n                target_f = as.numeric(target_f)/100,\n                n_species = 4) %&gt;% \n  dplyr::select(-name) %&gt;% \n  dplyr::relocate(microcosm_id, n_species) %&gt;% \n  readr::write_tsv(here::here(data, \"quartets_sample_composition_long.tsv\"))",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "3. Species quartets"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#global-variables",
    "href": "R/experiment_design/02_trios.html#global-variables",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "data &lt;- here::here(\"data\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/experiment_design/02_trios.html#format-and-save",
    "href": "R/experiment_design/02_trios.html#format-and-save",
    "title": "Designing three-species subcommunities",
    "section": "2.1 Format and save",
    "text": "2.1 Format and save\n\ncombos03_filt_wells %&gt;%\n  group_by(a, b, c) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         c_sp = paste0(str_split_i(c, \"_\", 2), stringr::str_extract(str_split_i(c, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3),\n         c_f = str_split_i(c, \"_\", 3)) %&gt;% \n  arrange(well) %&gt;% \n  dplyr::select(microcosm_id, well, a, a_sp, a_f, b, b_sp, b_f, c, c_sp, c_f) %&gt;% \n  readr::write_tsv(here::here(data, \"trios_sample_composition_wide.tsv\"))\n\n\ncombos03_filt_wells %&gt;%\n  group_by(a, b, c) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  dplyr::select(a:c, well, microcosm_id) %&gt;% \n  tidyr::pivot_longer(c(-well, -microcosm_id)) %&gt;% \n  tidyr::separate(value, c(\"evo_hist\", \"strainID\", \"target_f\")) %&gt;% \n  dplyr::mutate(evo_hist = stringr::str_to_lower(evo_hist),\n                strainID = paste0(\"HAMBI_\", strainID),\n                target_f = as.numeric(target_f)/100,\n                n_species = 3) %&gt;% \n  dplyr::select(-name) %&gt;% \n  dplyr::relocate(microcosm_id, n_species) %&gt;% \n  readr::write_tsv(here::here(data, \"trios_sample_composition_long.tsv\"))",
    "crumbs": [
      "Experiment design - 96 Well plate layout",
      "2. Species trios"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html",
    "href": "R/optical_density/01_format_plot_od.html",
    "title": "Formatting and plotting optical density data",
    "section": "",
    "text": "In the main experiment, species pairs, trios, or quartets were serially passaged every 48 hours to fresh media containing the necessary concentration of streptomycin. The experiment was terminated after 8 of these growth cycles (16 days). The optical density (600 nm) was measured on alternating serial passage/growth cycles. This notebook contains results/plots for the optical density data.",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#libraries",
    "href": "R/optical_density/01_format_plot_od.html#libraries",
    "title": "Formatting and plotting optical density data",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(tidyverse)\nlibrary(ggforce)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#global-variables",
    "href": "R/optical_density/01_format_plot_od.html#global-variables",
    "title": "Formatting and plotting optical density data",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata &lt;- here::here(\"data\", \"optical_density\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#read-optical-density-data",
    "href": "R/optical_density/01_format_plot_od.html#read-optical-density-data",
    "title": "Formatting and plotting optical density data",
    "section": "2.3 Read optical density data",
    "text": "2.3 Read optical density data\n\npairs &lt;- readr::read_tsv(here::here(\"_data_raw\", \"20240606_optical_density\", \"optical_density_formatted.tsv\"))\n\nRows: 2880 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): community_id\ndbl (5): transfers, n_species, strep_conc, replicate, OD\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntqs &lt;- readr::read_tsv(here::here(\"_data_raw\", \"20240829_optical_density\", \"optical_density_formatted.tsv\")) %&gt;% \n  mutate(well = paste0(str_extract(well, \"[A-H]\"),\n                               str_pad(str_extract(well, \"\\\\d+\"), 2, side = \"left\", pad = \"0\")))\n\nRows: 7680 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): well\ndbl (5): transfers, n_species, strep_conc, replicate, OD\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#read-and-format-community-information",
    "href": "R/optical_density/01_format_plot_od.html#read-and-format-community-information",
    "title": "Formatting and plotting optical density data",
    "section": "2.4 Read and format community information",
    "text": "2.4 Read and format community information\n\npairs_comp &lt;- readr::read_tsv(here::here(\"data\", \"experiment_design\", \"pairs_sample_composition.tsv\")) %&gt;%\n  dplyr::mutate(name = paste(str_to_upper(evo_hist), str_remove(strainID, \"HAMBI_\"), target_f*100, sep = \"_\")) %&gt;% \n  dplyr::select(community_id, name) %&gt;%\n  dplyr::group_by(community_id) %&gt;% \n  dplyr::mutate(id = 1:n()) %&gt;% \n  dplyr::ungroup() %&gt;% \n  tidyr::pivot_wider(names_from = id, values_from = name ) %&gt;%\n  dplyr::rename(a = `1`, b = `2`) %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3)) %&gt;% \n  arrange(community_id) %&gt;% \n  mutate(n_species = 2,\n         sp = paste(a_sp, b_sp, sep = \"|\"),\n         f = paste(a_f, b_f, sep = \"|\"))\n\nRows: 96 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (3): community_id, evo_hist, strainID\ndbl (1): target_f\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntrios_comp &lt;- readr::read_tsv(here::here(\"data\", \"experiment_design\", \"trios_sample_composition_wide.tsv\")) %&gt;% \n  dplyr::mutate(n_species = 3,\n                sp = paste(a_sp, b_sp, c_sp, sep = \"|\"),\n                f = paste(a_f, b_f, c_f, sep = \"|\"))\n\nRows: 96 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (7): well, a, a_sp, b, b_sp, c, c_sp\ndbl (4): microcosm_id, a_f, b_f, c_f\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nquart_comp &lt;- readr::read_tsv(here::here(\"data\", \"experiment_design\", \"quartets_sample_composition_wide.tsv\")) %&gt;% \n  mutate(n_species = 4,\n         sp = paste(a_sp, b_sp, c_sp, d_sp, sep = \"|\"),\n         f = paste(a_f, b_f, c_f, d_f, sep = \"|\"))\n\nRows: 64 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (9): well, a, a_sp, b, b_sp, c, c_sp, d, d_sp\ndbl (5): microcosm_id, a_f, b_f, c_f, d_f\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#subset-to-pairs-trios-and-quartets",
    "href": "R/optical_density/01_format_plot_od.html#subset-to-pairs-trios-and-quartets",
    "title": "Formatting and plotting optical density data",
    "section": "2.5 Subset to pairs, trios, and quartets",
    "text": "2.5 Subset to pairs, trios, and quartets\nAlso we take the mean and std dev for the 2 replicates of each condition\n\npairs_combo &lt;- left_join(pairs_comp, pairs, by = join_by(community_id, n_species)) %&gt;% \n  summarize(OD_mn = mean(OD),\n            OD_sd = sd(OD),\n            .by = c(sp, f, transfers, strep_conc)) %&gt;% \n  mutate(strep_conc = as.factor(strep_conc))\n\ntrios_combo &lt;- left_join(trios_comp, tqs, by = join_by(well, n_species)) %&gt;% \n  summarize(OD_mn = mean(OD),\n            OD_sd = sd(OD),\n            .by = c(sp, f, transfers, strep_conc)) %&gt;% \n  mutate(strep_conc = as.factor(strep_conc))\n\nquart_combo &lt;- left_join(quart_comp, tqs, by = join_by(well, n_species)) %&gt;% \n  summarize(OD_mn = mean(OD),\n            OD_sd = sd(OD),\n            .by = c(sp, f, transfers, strep_conc)) %&gt;% \n  mutate(strep_conc = as.factor(strep_conc))",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#plotting-function",
    "href": "R/optical_density/01_format_plot_od.html#plotting-function",
    "title": "Formatting and plotting optical density data",
    "section": "3.1 Plotting function",
    "text": "3.1 Plotting function\n\nplot_od_grid &lt;- function(df, remove_first_cycle = TRUE, ncol){\n  pj &lt;- ggplot2::position_jitterdodge(jitter.width=0.0,\n                           jitter.height = 0.0,\n                           dodge.width = 0.5,\n                           seed=9)\n  \n  df %&gt;% \n    dplyr::filter(if(remove_first_cycle) transfers &gt; 2 else transfers &gt; 0) %&gt;%\n    ggplot2::ggplot(aes(x = transfers, y = OD_mn, color = strep_conc, group = interaction(strep_conc, f))) + \n    ggplot2::geom_linerange(aes(ymin = OD_mn - OD_sd, ymax = OD_mn + OD_sd, color = strep_conc), position = pj) + \n    ggh4x::geom_pointpath(aes(shape = f), position = pj, mult = 0.2) +\n    #ggplot2::geom_point() + \n    #ggplot2::geom_line(aes(linetype = f)) + \n    ggplot2::facet_wrap(~sp, ncol = ncol) +\n    ggplot2::labs(x = \"Growth cycle\", y = \"OD600\", color = \"Strep μg/ml\", shape = \"Mix ratio\") +\n    ggplot2::scale_color_viridis_d() +\n    ggplot2::theme_bw() + \n    ggplot2::theme(strip.background = element_blank(),\n        legend.position = \"bottom\", \n        axis.text = element_text(size = 8),\n        strip.text = element_text(size = 8))\n}",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#pairs",
    "href": "R/optical_density/01_format_plot_od.html#pairs",
    "title": "Formatting and plotting optical density data",
    "section": "3.2 Pairs",
    "text": "3.2 Pairs\n\nfig_pairs &lt;- plot_od_grid(pairs_combo, remove_first_cycle = TRUE, ncol = 4)\n\n# ggsave(\n#   here::here(\"figs\", \".svg\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"svg\"\n# )\n# \n# ggsave(\n#   here::here(\"figs\", \".png\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"png\"\n# )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Species pairs optical density (y-axis) over series of 48 hour growth cycles (x-axis, 16 days total). Different panels in the grid contain distinct species pairs (A = ancestral, E = strep evolved). Colors show Streptomycin concentration in μg/ml and point shape shows the initial mixing ratio of each species (in the same order as specie listed in each panel). Note that data from the first growth cycle (after 48 hours) is excluded for ease of viewing.\n\n\n\n\n3.2.1 Pairs with first growth cycle\n\n\n\n\nplot_od_grid(pairs_combo, remove_first_cycle = FALSE, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nFigure 2: As in Figure 1 but including data from the first growth cycle.",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#trios",
    "href": "R/optical_density/01_format_plot_od.html#trios",
    "title": "Formatting and plotting optical density data",
    "section": "3.3 Trios",
    "text": "3.3 Trios\n\nfig_trios &lt;- plot_od_grid(trios_combo, remove_first_cycle = TRUE, ncol = 4)\n\n# ggsave(\n#   here::here(\"figs\", \".svg\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"svg\"\n# )\n# \n# ggsave(\n#   here::here(\"figs\", \".png\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"png\"\n# )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Species trios optical density (y-axis) over series of 48 hour growth cycles (x-axis, 16 days total). Different panels in the grid contain distinct species pairs (A = ancestral, E = strep evolved). Colors show Streptomycin concentration in μg/ml and point shape shows the initial mixing ratio of each species (in the same order as species listed in each panel). Note that data from the first growth cycle (after 48 hours) is excluded for ease of viewing.\n\n\n\n\n3.3.1 Trios with first growth cycle\n\n\n\n\nplot_od_grid(trios_combo, remove_first_cycle = FALSE, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nFigure 4: As in Figure 3 but including data from the first growth cycle.",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/optical_density/01_format_plot_od.html#quartets",
    "href": "R/optical_density/01_format_plot_od.html#quartets",
    "title": "Formatting and plotting optical density data",
    "section": "3.4 Quartets",
    "text": "3.4 Quartets\n\nfig_quarts &lt;- plot_od_grid(quart_combo, remove_first_cycle = TRUE, ncol = 4)\n\n# ggsave(\n#   here::here(\"figs\", \".svg\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"svg\"\n# )\n# \n# ggsave(\n#   here::here(\"figs\", \".png\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"png\"\n# )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Species quartets optical density (y-axis) over series of 48 hour growth cycles (x-axis, 16 days total). Different panels in the grid contain distinct species pairs (A = ancestral, E = strep evolved). Colors show Streptomycin concentration in μg/ml and point shape shows the initial mixing ratio of each species (in the same order as species listed in each panel). Note that data from the first growth cycle (after 48 hours) is excluded for ease of viewing.\n\n\n\n\n3.4.1 Quartets with first growth cycle\n\n\n\n\nplot_od_grid(quart_combo, remove_first_cycle = FALSE, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nFigure 6: As in Figure 5 but including data from the first growth cycle.",
    "crumbs": [
      "Community density (optical density)",
      "1. Process and plot OD data"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html",
    "href": "R/bioscreen/01_format_growthcurves_batch.html",
    "title": "Formatting bioscreen growth curves",
    "section": "",
    "text": "Before the main experiment we grew each ancestral and evolved form of each species in 100% R2A media at a range of streptomycin concentrations. We measured the optical density of the cultures in a high-throughput platereader (Bioscreen) over 48 hours. From this data we can estimate the growth rate and the carrying capacity of each species in the different streptomycin concentrations.\nWe also grew all the ancestral and evolved forms of each species for 48 hours in 100% R2A media. We filtered the spent media of each species and evolved form, collected the filtrate, and grew each species/evo form in the filtrate of every other species. Again, we measured the optical density of the cultures grown on these filtrates in a high-throughput platereader (Bioscreen) over 48 hours.\nIn this notebook we will read the output from the bioscreen plate reader and format it for later plotting and analysis.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#libraries",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#libraries",
    "title": "Formatting bioscreen growth curves",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(here)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(ggforce)\nlibrary(slider)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#global-variables",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#global-variables",
    "title": "Formatting bioscreen growth curves",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240328_bioscreen\")\ndata &lt;- here::here(\"data\", \"20240328_bioscreen\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#functions",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#functions",
    "title": "Formatting bioscreen growth curves",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nFor plotting results\n\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate_name == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, bioscreen_well, plate_name), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_rollmean), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ bioscreen_well, nrow = rows, ncol = cols, page = page, scales = \"free_y\"), \n      ggplot2::theme(axis.text = element_text(size = 5))\n    )\n}",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#deal-with-encoding-issues",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#deal-with-encoding-issues",
    "title": "Formatting bioscreen growth curves",
    "section": "3.1 Deal with encoding issues",
    "text": "3.1 Deal with encoding issues\nFirst we need to know what encoding the file has\n\nreadr::guess_encoding(\n  here::here(data_raw,\n    \"bioscreen_strep_01.txt\"\n  )\n)\n\n\n  \n\n\n\nBioscreen files are in UTF-16E.\n\n3.1.1 List files\n\nfiles &lt;- fs::dir_ls(\n  path = data_raw,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.txt\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nfiles_named &lt;- rlang::set_names(files, nm = purrr::map_chr(files, fs::path_file) %&gt;% str_remove(\".txt\"))\n\n\n\n3.1.2 Read file using base R\nMust use read.delim as it is the only tool that I could find that handled the UTF-16LE correctly\n\nraw_df &lt;- purrr::map(\n  files_named,\n  read.delim,\n  # this is the encoding we deduced above\n  fileEncoding = \"UTF-16LE\",\n  skipNul = TRUE,\n  # telling it there is no header for colulmn names\n  header = FALSE,\n  sep = \" \",\n  colClasses = \"character\",\n  strip.white = TRUE,\n  na.strings = \"\",\n  # skip the first 3 lines because\n  skip = 3,\n  quote = \"\",\n  allowEscapes = FALSE,\n  comment.char = \"\",\n) %&gt;% purrr::list_rbind(names_to = \"plate_name\")\n\n\n\n3.1.3 Fix locale issues\n\nraw_df_decimal &lt;- readr::type_convert(\n  raw_df,\n  locale = readr::locale(decimal_mark = \",\", grouping_mark = \".\"),\n  cols(\n    .default = col_double(),\n    plate_name = col_character(),\n    V1 = col_time(format = \"\"),\n    V203 = col_logical()\n  )\n) %&gt;%\n  tibble::as_tibble()\n\n\n\n3.1.4 Fix weird time encoding\nThe V1 variable has time encoded as Hr:Min:Sec which we want to convert to just seconds\nThe rounding step is necessary because the bioscreen actually doesn’t output consistent intervals. Sometimes it is 00:30:06 and other times it is 00:30:05. This becomes a problem later on when trying to combine multiple runs at once\n\nround_any &lt;- function(x, accuracy, f=round){\n  f(x/ accuracy) * accuracy\n}\n\nraw_df_decimal_sec &lt;- dplyr::mutate(raw_df_decimal, \n                                    V1 = round_any(lubridate::period_to_seconds(lubridate::hms(V1)), 100)\n                                    )\n\n\n\n3.1.5 Remove extraneous columns.\nSome of the columns have no useful data whatsoever. We need to get rid of those.\n\ndplyr::select(raw_df_decimal_sec, tidyselect::last_col(offset = 1), tidyselect::last_col())\n\n\n  \n\n\n\n\ndplyr::select(raw_df_decimal_sec, tidyselect::num_range(\"V\", 1:4))\n\n\n  \n\n\n\nThe last columns is V203 and has nothing. Column V2 is just blank. Now we’ll just keep the columns we need.\n\ngcurves_slurped_fmt &lt;- raw_df_decimal_sec %&gt;% \n  dplyr::select(plate_name, V1, V3:V202) %&gt;% \n  dplyr::mutate(hours = lubridate::time_length(V1, unit = \"hours\")) %&gt;%\n  tidyr::pivot_longer(c(-plate_name, -hours, -V1), names_to = \"well\", values_to = \"OD600\") %&gt;%\n  # here we remove the V part and subtract 2 so that bioscreen well numbers will go from 1:100 per plate\n  dplyr::mutate(bioscreen_well = as.numeric(str_remove(well, \"V\"))-2) %&gt;% \n  dplyr::rename(seconds = V1)",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#read-metadata",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#read-metadata",
    "title": "Formatting bioscreen growth curves",
    "section": "4.1 Read metadata",
    "text": "4.1 Read metadata\nStreptomycin and filtrate conditions\n\ngcurves_slurped_fmt_md &lt;- readr::read_tsv(\n  here::here(data_raw, \"plate_conditions.tsv\"),\n  col_names = TRUE,\n  cols(\n    plate_name = col_character(),\n    plate_number = col_double(),\n    bioscreen_well = col_double(),\n    replicate = col_double(),\n    sp_hist = col_character(),\n    strep_conc = col_double(),\n    sp_filtrate = col_character()\n  )\n)",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#join-with-metadata-to-remove-ununsed-samples",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#join-with-metadata-to-remove-ununsed-samples",
    "title": "Formatting bioscreen growth curves",
    "section": "4.2 Join with metadata to remove ununsed samples",
    "text": "4.2 Join with metadata to remove ununsed samples\n\ngcurves &lt;- dplyr::left_join(\n  gcurves_slurped_fmt_md,\n  gcurves_slurped_fmt,\n  by = dplyr::join_by(plate_name, bioscreen_well)\n)\n\nOne thing I’ve realized is that many methods for inferring growth rates struggle when the density of observations is too high (e.g., one measurement every 5 minutes). In reality I’ve found that taking one measurement every 15 minutes is sufficient. Here we thin it out so that measurements are in 20 minute intervals. This seems to improve the fitting procedure a lot without much of a cost.\n\ngcurves_thin &lt;- gcurves %&gt;% \n  # 1200 is 20 minutes so by ensuring modulo = 0 we include only time points\n  # 0, 20, 40, 60 minutes and so on...\n  dplyr::filter(seconds %% 1200 == 0)\n\nNow we’ll do some smoothing to reduce the “jaggedness” of the curves a bit. We use the slider package with a 5 point rolling mean for each focal observation we take the mean including the focal point and two points before and after.\n\ngcurves_thin_sm &lt;- gcurves_thin %&gt;% \n  dplyr::group_by(plate_name, bioscreen_well) %&gt;% \n  dplyr::mutate(OD600_rollmean = slider::slide_dbl(OD600, mean, .before = 2, .after = 2)) %&gt;% \n  ungroup()",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_01",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_01",
    "title": "Formatting bioscreen growth curves",
    "section": "5.1 bioscreen_strep_01",
    "text": "5.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_02",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_02",
    "title": "Formatting bioscreen growth curves",
    "section": "5.2 bioscreen_strep_02",
    "text": "5.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_03",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_03",
    "title": "Formatting bioscreen growth curves",
    "section": "5.3 bioscreen_strep_03",
    "text": "5.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Bioscreen plate “bioscreen_strep_03” wells 1-70 Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_01",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_01",
    "title": "Formatting bioscreen growth curves",
    "section": "5.4 bioscreen_pairwise_filtrates_01",
    "text": "5.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80 Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160 Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_02",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_02",
    "title": "Formatting bioscreen growth curves",
    "section": "5.5 bioscreen_pairwise_filtrates_02",
    "text": "5.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#conclusions",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#conclusions",
    "title": "Formatting bioscreen growth curves",
    "section": "5.6 Conclusions",
    "text": "5.6 Conclusions\nGrowth curves all look reasonable. Can proceed with the analysis.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#spline-based-estiamte",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#spline-based-estiamte",
    "title": "Formatting bioscreen growth curves",
    "section": "6.1 Spline based estiamte",
    "text": "6.1 Spline based estiamte\nSmoothing splines are a quick method to estimate maximum growth. The method is called nonparametric, because the growth rate is directly estimated from the smoothed data without being restricted to a specific model formula.\nFrom growthrates documentation:\n\nThe method was inspired by an algorithm of Kahm et al. (2010), with different settings and assumptions. In the moment, spline fitting is always done with log-transformed data, assuming exponential growth at the time point of the maximum of the first derivative of the spline fit. All the hard work is done by function smooth.spline from package stats, that is highly user configurable. Normally, smoothness is automatically determined via cross-validation. This works well in many cases, whereas manual adjustment is required otherwise, e.g. by setting spar to a fixed value [0, 1] that also disables cross-validation.\n\n\n6.1.1 Fit\n\nset.seed(45278)\nmany_spline &lt;- growthrates::all_splines(OD600_rollmean ~ hours | id, data = gcurves_thin_sm, spar = 0.5)\n\nreadr::write_rds(many_spline, here::here(data, \"spline_fits\"))\n\n\n\n6.1.2 Results\n\nmany_spline_res &lt;- growthrates::results(many_spline)\n\n\n\n6.1.3 Predictions\n\nmany_spline_xy &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x = x@xy[1], y = x@xy[2])) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\"))\n\nmany_spline_fitted &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\")) %&gt;%\n  dplyr::group_by(id) %&gt;% \n  # this step makes sure we don't plot fits that go outside the range of the data\n  dplyr::mutate(predicted = dplyr::if_else(dplyr::between(predicted, min(OD600_rollmean), max(OD600_rollmean)), predicted, NA_real_)) %&gt;% \n  dplyr::ungroup()\n\n\n\n6.1.4 Plot\n\n6.1.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#linear-model-based-estimate",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#linear-model-based-estimate",
    "title": "Formatting bioscreen growth curves",
    "section": "6.2 Linear model based estimate",
    "text": "6.2 Linear model based estimate\nThis method determine maximum growth rates from the log-linear part of a growth curve using a heuristic approach similar to the “growth rates made easy” method of Hall et al. (2013).\nFrom growthrates documentation:\n\nThe algorithm works as follows:\n1. Fit linear regressions to all subsets of h consecutive data points. If for example h = 5, fit a linear regression to points 1 . . . 5, 2 . . . 6, 3. . . 7 and so on. The method seeks the highest rate of exponential growth, so the dependent variable is of course log-transformed.\n2. Find the subset with the highest slope bmax and include also the data points of adjacent subsets that have a slope of at least quota · bmax, e.g. all data sets that have at least 95% of the maximum slope.\n3. Fit a new linear model to the extended data window identified in step 2.\n\n\n6.2.1 Fit\n\nset.seed(45278)\nmany_linear &lt;- growthrates::all_easylinear(OD600_rollmean ~ hours | id, data = gcurves_thin_sm)\n\nreadr::write_rds(many_linear, here::here(data, \"linear_fits\"))\n\n\n\n6.2.2 Results\n\nmany_linear_res &lt;- growthrates::results(many_linear)\n\n\n\n6.2.3 Predictions\n\nmany_linear_fitted &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\")) %&gt;%\n  dplyr::group_by(id) %&gt;% \n  # this step makes sure we don't plot fits that go outside the range of the data\n  dplyr::mutate(predicted = dplyr::if_else(dplyr::between(predicted, min(OD600_rollmean), max(OD600_rollmean)), predicted, NA_real_)) %&gt;% \n  dplyr::ungroup()\n\n\n\n6.2.4 Plot\n\n6.2.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#baranyi-parametric-fit-estimate",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#baranyi-parametric-fit-estimate",
    "title": "Formatting bioscreen growth curves",
    "section": "6.3 Baranyi parametric fit estimate",
    "text": "6.3 Baranyi parametric fit estimate\nThis uses the growth model of Baranyi and Roberts (1995) written as analytical solution of the system of differential equations.\nFrom growthrates documentation:\n\nThe version of the equation used in this package has the following form:\n\\(A = time + \\frac{1}{mumax} \\times \\log((−\\mu_{max} \\times time) +exp(−h_{0})−exp(−\\mu_{max} \\times time−h0))\\)\n\\(\\log(y) = \\log(y_{0}) + \\mu_{max} \\times A − log(1 + \\frac{\\exp(\\mu_{max} \\times A) − 1}{\\exp(\\log(K) − \\log(y_{0})})\\)\n\n\n6.3.1 Fit\n\nset.seed(783622)\n\n# starting values and limits for the baranyi model\np   &lt;- c(y0 = 0.03, mumax = .1, K = 0.1, h0 = 1)\nlower   &lt;- c(y0 = 0.001, mumax = 1e-2, K = 0.005, h0 = 0)\nupper   &lt;- c(y0 = 0.1,   mumax = 1,    K = 0.9,   h0 = 10)\n\nmany_baranyi &lt;- growthrates::all_growthmodels(\n                   OD600_rollmean ~ growthrates::grow_baranyi(hours, parms) | id,\n                   data = gcurves_thin_sm,\n                   p = p, lower = lower, upper = upper,\n                   transform = \"log\", ncores = 8)\n\nreadr::write_rds(many_baranyi, here::here(data, \"barayani_fits\"))\n\n\n\n6.3.2 Results\n\nmany_baranyi_res &lt;- growthrates::results(many_baranyi)\n\n\n\n6.3.3 Predictions\n\nmany_baranyi_fitted &lt;- purrr::map(many_baranyi@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\"))\n\n\n\n6.3.4 Plot\n\n6.3.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 33: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 34: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 35: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 36: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 37: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 38: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 39: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 40: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#huang-parametric-fit-estimate",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#huang-parametric-fit-estimate",
    "title": "Formatting bioscreen growth curves",
    "section": "6.4 Huang parametric fit estimate",
    "text": "6.4 Huang parametric fit estimate\nHuangs growth model (ref 1, ref 2) written as analytical solution of the differential equations.\nFrom growthrates documentation:\n\nThe version of the equation used in this package has the following form:\n\\(B = time + \\frac{1}{alpha} \\times \\log(\\frac{1 + exp(−\\alpha \\times (time - \\lambda))}{1 + exp(\\alpha \\times \\lambda})\\)\n\\(\\log(y) = \\log(y_{0}) + \\log(K) − \\log(y_{0} + (K − y_{0}) \\times exp(−\\mu_{max} \\times B))\\)\nIn contrast to the original publication, all parameters related to population abundance (y, y0, K) are given as untransformed values. They are not log-transformed. In general, using log-transformed parameters would indeed be a good idea to avoid the need of constained optimization, but tests showed that box-constrained optimization worked resonably well. Therefore, handling of optionally log-transformed parameters was removed from the package to avoid confusion. If you want to discuss this, please let me know.\n\n\n6.4.1 Fit\n\nset.seed(123784)\n\n# starting values and limits for the huang model\np   &lt;- c(y0 = 0.03, mumax = .1, K = 0.1, alpha = 1.5, lambda = 3)\nlower   &lt;- c(y0 = 0.001, mumax = 1e-2, K = 0.005, alpha = 0.1, lambda = 0.03)\nupper   &lt;- c(y0 = 0.1,   mumax = 1,    K = 0.9,   alpha = 15, lambda = 15)\n\nmany_huang &lt;- growthrates::all_growthmodels(\n                   OD600_rollmean ~ growthrates::grow_huang(hours, parms) | id,\n                   data = gcurves_thin_sm,\n                   p = p, lower = lower, upper = upper,\n                   transform = \"log\", ncores = 8)\n\nreadr::write_rds(many_huang, here::here(data, \"huang_fits\"))\n\n\n\n6.4.2 Results\n\nmany_huang_res &lt;- growthrates::results(many_huang)\n\n\n\n6.4.3 Predictions\n\nmany_huang_fitted &lt;- purrr::map(many_huang@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\"))\n\n\n\n6.4.4 Plot\n\n6.4.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 41: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 42: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n6.4.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 43: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 44: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huangv model.\n\n\n\n\n\n6.4.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 45: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 46: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n6.4.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 47: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 48: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n6.4.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 49: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 50: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/bioscreen/01_format_growthcurves_batch.html#auc",
    "href": "R/bioscreen/01_format_growthcurves_batch.html#auc",
    "title": "Formatting bioscreen growth curves",
    "section": "6.5 AUC",
    "text": "6.5 AUC\nCalculates AUC using DescTools package\n\nmany_auc_res &lt;- gcurves_thin_sm %&gt;% \n  dplyr::summarize(auc = DescTools::AUC(hours, OD600_rollmean),\n            max_od = max(OD600_rollmean),\n            min_od = min(OD600_rollmean),\n            .by = id) %&gt;% \n  dplyr::left_join(dplyr::distinct(dplyr::select(gcurves_thin_sm, id, plate_name:sp_filtrate))) %&gt;% \n  dplyr::select(-id) %&gt;% \n  dplyr::relocate(auc, max_od, min_od, .after=\"sp_filtrate\")\n\nJoining with `by = join_by(id)`",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html",
    "title": "Formatting bioscreen growth curves",
    "section": "",
    "text": "Before the main experiment we grew each ancestral and evolved form of each species in 100% R2A media at a range of streptomycin concentrations. We measured the optical density of the cultures in a high-throughput platereader (Bioscreen) over 48 hours. From this data we can estimate the growth rate and the carrying capacity of each species in the different streptomycin concentrations.\nWe also grew all the ancestral and evolved forms of each species for 48 hours in 100% R2A media. We filtered the spent media of each species and evolved form, collected the filtrate, and grew each species/evo form in the filtrate of every other species. Again, we measured the optical density of the cultures grown on these filtrates in a high-throughput platereader (Bioscreen) over 48 hours.\nIn this notebook we will read the output from the bioscreen plate reader and format it for later plotting and analysis.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#libraries",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#libraries",
    "title": "Formatting bioscreen growth curves",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(here)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(ggforce)\nlibrary(slider)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#global-variables",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#global-variables",
    "title": "Formatting bioscreen growth curves",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20240328_bioscreen\")\ndata &lt;- here::here(\"data\", \"monocultures\", \"20240328_bioscreen\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#functions",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#functions",
    "title": "Formatting bioscreen growth curves",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nFor plotting results\n\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate_name == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, bioscreen_well, plate_name), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_rollmean), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ bioscreen_well, nrow = rows, ncol = cols, page = page, scales = \"free_y\"), \n      ggplot2::theme(axis.text = element_text(size = 5))\n    )\n}",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#deal-with-encoding-issues",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#deal-with-encoding-issues",
    "title": "Formatting bioscreen growth curves",
    "section": "3.1 Deal with encoding issues",
    "text": "3.1 Deal with encoding issues\nFirst we need to know what encoding the file has\n\nreadr::guess_encoding(\n  here::here(data_raw,\n    \"bioscreen_strep_01.txt\"\n  )\n)\n\n\n  \n\n\n\nBioscreen files are in UTF-16E.\n\n3.1.1 List files\n\nfiles &lt;- fs::dir_ls(\n  path = data_raw,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.txt\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nfiles_named &lt;- rlang::set_names(files, nm = purrr::map_chr(files, fs::path_file) %&gt;% str_remove(\".txt\"))\n\n\n\n3.1.2 Read file using base R\nMust use read.delim as it is the only tool that I could find that handled the UTF-16LE correctly\n\nraw_df &lt;- purrr::map(\n  files_named,\n  read.delim,\n  # this is the encoding we deduced above\n  fileEncoding = \"UTF-16LE\",\n  skipNul = TRUE,\n  # telling it there is no header for colulmn names\n  header = FALSE,\n  sep = \" \",\n  colClasses = \"character\",\n  strip.white = TRUE,\n  na.strings = \"\",\n  # skip the first 3 lines because\n  skip = 3,\n  quote = \"\",\n  allowEscapes = FALSE,\n  comment.char = \"\",\n) %&gt;% purrr::list_rbind(names_to = \"plate_name\")\n\n\n\n3.1.3 Fix locale issues\n\nraw_df_decimal &lt;- readr::type_convert(\n  raw_df,\n  locale = readr::locale(decimal_mark = \",\", grouping_mark = \".\"),\n  cols(\n    .default = col_double(),\n    plate_name = col_character(),\n    V1 = col_time(format = \"\"),\n    V203 = col_logical()\n  )\n) %&gt;%\n  tibble::as_tibble()\n\n\n\n3.1.4 Fix weird time encoding\nThe V1 variable has time encoded as Hr:Min:Sec which we want to convert to just seconds\nThe rounding step is necessary because the bioscreen actually doesn’t output consistent intervals. Sometimes it is 00:30:06 and other times it is 00:30:05. This becomes a problem later on when trying to combine multiple runs at once\n\nround_any &lt;- function(x, accuracy, f=round){\n  f(x/ accuracy) * accuracy\n}\n\nraw_df_decimal_sec &lt;- dplyr::mutate(raw_df_decimal, \n                                    V1 = round_any(lubridate::period_to_seconds(lubridate::hms(V1)), 100)\n                                    )\n\n\n\n3.1.5 Remove extraneous columns.\nSome of the columns have no useful data whatsoever. We need to get rid of those.\n\ndplyr::select(raw_df_decimal_sec, tidyselect::last_col(offset = 1), tidyselect::last_col())\n\n\n  \n\n\n\n\ndplyr::select(raw_df_decimal_sec, tidyselect::num_range(\"V\", 1:4))\n\n\n  \n\n\n\nThe last columns is V203 and has nothing. Column V2 is just blank. Now we’ll just keep the columns we need.\n\ngcurves_slurped_fmt &lt;- raw_df_decimal_sec %&gt;% \n  dplyr::select(plate_name, V1, V3:V202) %&gt;% \n  dplyr::mutate(hours = lubridate::time_length(V1, unit = \"hours\")) %&gt;%\n  tidyr::pivot_longer(c(-plate_name, -hours, -V1), names_to = \"well\", values_to = \"OD600\") %&gt;%\n  # here we remove the V part and subtract 2 so that bioscreen well numbers will go from 1:100 per plate\n  dplyr::mutate(bioscreen_well = as.numeric(str_remove(well, \"V\"))-2) %&gt;% \n  dplyr::rename(seconds = V1)",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#read-metadata",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#read-metadata",
    "title": "Formatting bioscreen growth curves",
    "section": "4.1 Read metadata",
    "text": "4.1 Read metadata\nStreptomycin and filtrate conditions\n\ngcurves_slurped_fmt_md &lt;- readr::read_tsv(\n  here::here(data_raw, \"plate_conditions.tsv\"),\n  col_names = TRUE,\n  cols(\n    plate_name = col_character(),\n    plate_number = col_double(),\n    bioscreen_well = col_double(),\n    replicate = col_double(),\n    sp_hist = col_character(),\n    strep_conc = col_double(),\n    sp_filtrate = col_character()\n  )\n)",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#join-with-metadata-to-remove-ununsed-samples",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#join-with-metadata-to-remove-ununsed-samples",
    "title": "Formatting bioscreen growth curves",
    "section": "4.2 Join with metadata to remove ununsed samples",
    "text": "4.2 Join with metadata to remove ununsed samples\n\ngcurves &lt;- dplyr::left_join(\n  gcurves_slurped_fmt_md,\n  gcurves_slurped_fmt,\n  by = dplyr::join_by(plate_name, bioscreen_well)\n)\n\nOne thing I’ve realized is that many methods for inferring growth rates struggle when the density of observations is too high (e.g., one measurement every 5 minutes). In reality I’ve found that taking one measurement every 15 minutes is sufficient. Here we thin it out so that measurements are in 20 minute intervals. This seems to improve the fitting procedure a lot without much of a cost.\n\ngcurves_thin &lt;- gcurves %&gt;% \n  # 1200 is 20 minutes so by ensuring modulo = 0 we include only time points\n  # 0, 20, 40, 60 minutes and so on...\n  dplyr::filter(seconds %% 1200 == 0)\n\nNow we’ll do some smoothing to reduce the “jaggedness” of the curves a bit. We use the slider package with a 5 point rolling mean for each focal observation we take the mean including the focal point and two points before and after.\n\ngcurves_thin_sm &lt;- gcurves_thin %&gt;% \n  dplyr::group_by(plate_name, bioscreen_well) %&gt;% \n  dplyr::mutate(OD600_rollmean = slider::slide_dbl(OD600, mean, .before = 2, .after = 2)) %&gt;% \n  ungroup()\n\nreadr::write_tsv(gcurves_thin_sm, here::here(data, \"gcurves_formatted_thinned.tsv\"))",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_01",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_01",
    "title": "Formatting bioscreen growth curves",
    "section": "5.1 bioscreen_strep_01",
    "text": "5.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_02",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_02",
    "title": "Formatting bioscreen growth curves",
    "section": "5.2 bioscreen_strep_02",
    "text": "5.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_03",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_strep_03",
    "title": "Formatting bioscreen growth curves",
    "section": "5.3 bioscreen_strep_03",
    "text": "5.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Bioscreen plate “bioscreen_strep_03” wells 1-70 Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_01",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_01",
    "title": "Formatting bioscreen growth curves",
    "section": "5.4 bioscreen_pairwise_filtrates_01",
    "text": "5.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80 Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160 Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_02",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#bioscreen_pairwise_filtrates_02",
    "title": "Formatting bioscreen growth curves",
    "section": "5.5 bioscreen_pairwise_filtrates_02",
    "text": "5.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#conclusions",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#conclusions",
    "title": "Formatting bioscreen growth curves",
    "section": "5.6 Conclusions",
    "text": "5.6 Conclusions\nGrowth curves all look reasonable. Can proceed with the analysis.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#spline-based-estiamte",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#spline-based-estiamte",
    "title": "Formatting bioscreen growth curves",
    "section": "6.1 Spline based estiamte",
    "text": "6.1 Spline based estiamte\nSmoothing splines are a quick method to estimate maximum growth. The method is called nonparametric, because the growth rate is directly estimated from the smoothed data without being restricted to a specific model formula.\nFrom growthrates documentation:\n\nThe method was inspired by an algorithm of Kahm et al. (2010), with different settings and assumptions. In the moment, spline fitting is always done with log-transformed data, assuming exponential growth at the time point of the maximum of the first derivative of the spline fit. All the hard work is done by function smooth.spline from package stats, that is highly user configurable. Normally, smoothness is automatically determined via cross-validation. This works well in many cases, whereas manual adjustment is required otherwise, e.g. by setting spar to a fixed value [0, 1] that also disables cross-validation.\n\n\n6.1.1 Fit\n\nset.seed(45278)\nmany_spline &lt;- growthrates::all_splines(OD600_rollmean ~ hours | id, data = gcurves_thin_sm, spar = 0.5)\n\nreadr::write_rds(many_spline, here::here(data, \"spline_fits\"))\n\n\n\n6.1.2 Results\n\nmany_spline_res &lt;- growthrates::results(many_spline)\n\n\n\n6.1.3 Predictions\n\nmany_spline_xy &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x = x@xy[1], y = x@xy[2])) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\"))\n\nmany_spline_fitted &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\")) %&gt;%\n  dplyr::group_by(id) %&gt;% \n  # this step makes sure we don't plot fits that go outside the range of the data\n  dplyr::mutate(predicted = dplyr::if_else(dplyr::between(predicted, min(OD600_rollmean), max(OD600_rollmean)), predicted, NA_real_)) %&gt;% \n  dplyr::ungroup()\n\n\n\n6.1.4 Plot\n\n6.1.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#linear-model-based-estimate",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#linear-model-based-estimate",
    "title": "Formatting bioscreen growth curves",
    "section": "6.2 Linear model based estimate",
    "text": "6.2 Linear model based estimate\nThis method determine maximum growth rates from the log-linear part of a growth curve using a heuristic approach similar to the “growth rates made easy” method of Hall et al. (2013).\nFrom growthrates documentation:\n\nThe algorithm works as follows:\n1. Fit linear regressions to all subsets of h consecutive data points. If for example h = 5, fit a linear regression to points 1 . . . 5, 2 . . . 6, 3. . . 7 and so on. The method seeks the highest rate of exponential growth, so the dependent variable is of course log-transformed.\n2. Find the subset with the highest slope bmax and include also the data points of adjacent subsets that have a slope of at least quota · bmax, e.g. all data sets that have at least 95% of the maximum slope.\n3. Fit a new linear model to the extended data window identified in step 2.\n\n\n6.2.1 Fit\n\nset.seed(45278)\nmany_linear &lt;- growthrates::all_easylinear(OD600_rollmean ~ hours | id, data = gcurves_thin_sm)\n\nreadr::write_rds(many_linear, here::here(data, \"linear_fits\"))\n\n\n\n6.2.2 Results\n\nmany_linear_res &lt;- growthrates::results(many_linear)\n\n\n\n6.2.3 Predictions\n\nmany_linear_fitted &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\")) %&gt;%\n  dplyr::group_by(id) %&gt;% \n  # this step makes sure we don't plot fits that go outside the range of the data\n  dplyr::mutate(predicted = dplyr::if_else(dplyr::between(predicted, min(OD600_rollmean), max(OD600_rollmean)), predicted, NA_real_)) %&gt;% \n  dplyr::ungroup()\n\n\n\n6.2.4 Plot\n\n6.2.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n6.2.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from a piecewise linear model fit.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#baranyi-parametric-fit-estimate",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#baranyi-parametric-fit-estimate",
    "title": "Formatting bioscreen growth curves",
    "section": "6.3 Baranyi parametric fit estimate",
    "text": "6.3 Baranyi parametric fit estimate\nThis uses the growth model of Baranyi and Roberts (1995) written as analytical solution of the system of differential equations.\nFrom growthrates documentation:\n\nThe version of the equation used in this package has the following form:\n\\(A = time + \\frac{1}{mumax} \\times \\log((−\\mu_{max} \\times time) +exp(−h_{0})−exp(−\\mu_{max} \\times time−h0))\\)\n\\(\\log(y) = \\log(y_{0}) + \\mu_{max} \\times A − log(1 + \\frac{\\exp(\\mu_{max} \\times A) − 1}{\\exp(\\log(K) − \\log(y_{0})})\\)\n\n\n6.3.1 Fit\n\nset.seed(783622)\n\n# starting values and limits for the baranyi model\np   &lt;- c(y0 = 0.03, mumax = .1, K = 0.1, h0 = 1)\nlower   &lt;- c(y0 = 0.001, mumax = 1e-2, K = 0.005, h0 = 0)\nupper   &lt;- c(y0 = 0.1,   mumax = 1,    K = 0.9,   h0 = 10)\n\nmany_baranyi &lt;- growthrates::all_growthmodels(\n                   OD600_rollmean ~ growthrates::grow_baranyi(hours, parms) | id,\n                   data = gcurves_thin_sm,\n                   p = p, lower = lower, upper = upper,\n                   transform = \"log\", ncores = 8)\n\nreadr::write_rds(many_baranyi, here::here(data, \"barayani_fits\"))\n\n\n\n6.3.2 Results\n\nmany_baranyi_res &lt;- growthrates::results(many_baranyi)\n\n\n\n6.3.3 Predictions\n\nmany_baranyi_fitted &lt;- purrr::map(many_baranyi@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\"))\n\n\n\n6.3.4 Plot\n\n6.3.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 33: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 34: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 35: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 36: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 37: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 38: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n6.3.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 39: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 40: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Baranyi 1995 model.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#huang-parametric-fit-estimate",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#huang-parametric-fit-estimate",
    "title": "Formatting bioscreen growth curves",
    "section": "6.4 Huang parametric fit estimate",
    "text": "6.4 Huang parametric fit estimate\nHuangs growth model (ref 1, ref 2) written as analytical solution of the differential equations.\nFrom growthrates documentation:\n\nThe version of the equation used in this package has the following form:\n\\(B = time + \\frac{1}{alpha} \\times \\log(\\frac{1 + exp(−\\alpha \\times (time - \\lambda))}{1 + exp(\\alpha \\times \\lambda})\\)\n\\(\\log(y) = \\log(y_{0}) + \\log(K) − \\log(y_{0} + (K − y_{0}) \\times exp(−\\mu_{max} \\times B))\\)\nIn contrast to the original publication, all parameters related to population abundance (y, y0, K) are given as untransformed values. They are not log-transformed. In general, using log-transformed parameters would indeed be a good idea to avoid the need of constained optimization, but tests showed that box-constrained optimization worked resonably well. Therefore, handling of optionally log-transformed parameters was removed from the package to avoid confusion. If you want to discuss this, please let me know.\n\n\n6.4.1 Fit\n\nset.seed(123784)\n\n# starting values and limits for the huang model\np   &lt;- c(y0 = 0.03, mumax = .1, K = 0.1, alpha = 1.5, lambda = 3)\nlower   &lt;- c(y0 = 0.001, mumax = 1e-2, K = 0.005, alpha = 0.1, lambda = 0.03)\nupper   &lt;- c(y0 = 0.1,   mumax = 1,    K = 0.9,   alpha = 15, lambda = 15)\n\nmany_huang &lt;- growthrates::all_growthmodels(\n                   OD600_rollmean ~ growthrates::grow_huang(hours, parms) | id,\n                   data = gcurves_thin_sm,\n                   p = p, lower = lower, upper = upper,\n                   transform = \"log\", ncores = 8)\n\nreadr::write_rds(many_huang, here::here(data, \"huang_fits\"))\n\n\n\n6.4.2 Results\n\nmany_huang_res &lt;- growthrates::results(many_huang)\n\n\n\n6.4.3 Predictions\n\nmany_huang_fitted &lt;- purrr::map(many_huang@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;% \n  purrr::list_rbind(names_to = \"id\") %&gt;% \n  dplyr::rename(hours = time, predicted = y) %&gt;% \n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;% \n  dplyr::mutate(id = stringr::str_remove_all(id, \"bioscreen_pairwise_|bioscreen_\"))\n\n\n\n6.4.4 Plot\n\n6.4.4.1 bioscreen_strep_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 41: Bioscreen plate “bioscreen_strep_01” wells 1-100. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 42: Bioscreen plate “bioscreen_strep_01” wells 101-200. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n6.4.4.2 bioscreen_strep_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 43: Bioscreen plate “bioscreen_strep_02” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 44: Bioscreen plate “bioscreen_strep_02” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huangv model.\n\n\n\n\n\n6.4.4.3 bioscreen_strep_03\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 45: Bioscreen plate “bioscreen_strep_03” wells 1-70. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 46: Bioscreen plate “bioscreen_strep_03” wells 71-140. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n6.4.4.4 bioscreen_pairwise_filtrates_01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 47: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 48: Bioscreen plate “bioscreen_pairwise_filtrates_01” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n6.4.4.5 bioscreen_pairwise_filtrates_02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 49: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 1-80. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 50: Bioscreen plate “bioscreen_pairwise_filtrates_02” wells 81-160. Blue line is smoothed with a moving average window of 5 points. Orange is fitted to the Huang model.",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#auc",
    "href": "R/monocultures/bioscreen/01_format_growthcurves_batch.html#auc",
    "title": "Formatting bioscreen growth curves",
    "section": "6.5 AUC",
    "text": "6.5 AUC\nCalculates AUC using DescTools package\n\nmany_auc_res &lt;- gcurves_thin_sm %&gt;% \n  dplyr::summarize(auc = DescTools::AUC(hours, OD600_rollmean),\n            max_od = max(OD600_rollmean),\n            min_od = min(OD600_rollmean),\n            .by = id) %&gt;% \n  dplyr::left_join(dplyr::distinct(dplyr::select(gcurves_thin_sm, id, plate_name:sp_filtrate))) %&gt;% \n  dplyr::select(-id) %&gt;% \n  dplyr::relocate(auc, max_od, min_od, .after=\"sp_filtrate\")\n\nJoining with `by = join_by(id)`",
    "crumbs": [
      "1. Monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html",
    "title": "Formatting Rbec output",
    "section": "",
    "text": "Contains results from pairs of all streptomycin concentrations and trios for 0 streptomycin from Milla’s bottom up community assembly experiment",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#libraries",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#libraries",
    "title": "Formatting Rbec output",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(archive)\nlibrary(scales)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#global-variables",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#global-variables",
    "title": "Formatting Rbec output",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240711_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"communities\", \"20240711_BTK_illumina_v3\")\namplicontar &lt;- here::here(data_raw, \"rbec_output.tar.gz\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#data",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#data",
    "title": "Formatting Rbec output",
    "section": "2.3 Data",
    "text": "2.3 Data\nNOTE! We have commented out the species not included in this experiment\n\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#functions",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#functions",
    "title": "Formatting Rbec output",
    "section": "2.4 Functions",
    "text": "2.4 Functions\n\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus)) %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species))) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#untar-rbec-output-tarball",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#untar-rbec-output-tarball",
    "title": "Formatting Rbec output",
    "section": "4.1 Untar Rbec output tarball",
    "text": "4.1 Untar Rbec output tarball\n\narchive::archive_extract(\n  amplicontar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#setup-directory-structure",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#setup-directory-structure",
    "title": "Formatting Rbec output",
    "section": "4.2 Setup directory structure",
    "text": "4.2 Setup directory structure\n\ntabdir &lt;- here::here(tmpdir, \"rbec_output\")\nsamppaths &lt;- fs::dir_ls(tabdir)\nsampnames &lt;- path_split(samppaths) %&gt;% \n  map_chr(dplyr::last)",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#read",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#read",
    "title": "Formatting Rbec output",
    "section": "4.3 Read",
    "text": "4.3 Read\n\nstraintabs &lt;- paste0(samppaths, \"/strain_table.txt\") %&gt;% \n  set_names(sampnames) %&gt;% \n  map_df(\n  read_tsv,\n  skip = 1,\n  col_names = c(\"rRNA16S_locus\",\"count\"),\n  show_col_types = FALSE, \n  .id = \"sample\") %&gt;% \n  # naming scheme inconsistent for one sample\n  mutate(sample = if_else(sample == \"P2_s_0\", \"P02_s_0\", sample))",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#negative-controls",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#negative-controls",
    "title": "Formatting Rbec output",
    "section": "6.1 Negative controls",
    "text": "6.1 Negative controls\nFirst, we’ll check whether the experimental and plate negative controls look good\n\nfinaltable %&gt;% \n  filter(str_detect(community_type, \"^neg|pos\")) %&gt;% \n  summarize(tot = sum(count_correct), .by = c(\"sample\", \"community_id\", \"n_species\", \"community_type\", \"replicate\"))\n\n\n  \n\n\n\nThis looks ok, but there are potentially some problems. Specifically, negative control replicates 2, 3, and 4 all have some contamination. neg_2_0 seems to be contaminated with HAMBI_1977, neg_3_0 with HAMBI_1287, and neg_4_0 with HAMBI_1977. However in the 5 remaining negative controls there is no contamination.",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#positive-controls",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#positive-controls",
    "title": "Formatting Rbec output",
    "section": "6.2 Positive controls",
    "text": "6.2 Positive controls\nThe positive controls should each have three species. In all cases the species that shouldn’t be there is very rare\n\nfinaltable %&gt;% \n  filter(str_detect(community_type, \"^pos\")) %&gt;%\n  mutate(total_pos_controls = n_distinct(sample)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = round(count_correct/sum(count_correct)*100)) %&gt;%\n  mutate(supposed_2_b_there = if_else(is.na(evo_hist), \"no\", \"yes\")) %&gt;% \n  relocate(f, supposed_2_b_there) %&gt;% \n  distinct(f, supposed_2_b_there, sample, strainID, count_correct, n_species, community_type,)\n\n\n  \n\n\n\nThis is also good - we detect all 3 species that should be there in the positive controls on each plate. In a later step we will use these control samples with metacal to try and correct for the boil prep extraction method.",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#misassigned-reads",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#misassigned-reads",
    "title": "Formatting Rbec output",
    "section": "6.3 Misassigned reads",
    "text": "6.3 Misassigned reads\nThese libraries were only prepared with samples from Milla’s 4-species experiment with 403, 1287, 1896, and 1977 so any time species other than these show up is just an incorrect assignment by Rbec. Let’s check quickly how many of these there are…\n\nfinaltable %&gt;% \n  filter(!str_detect(strainID, \"0403|1287|1896|1977\"))\n\n\n  \n\n\n\nThere is one or two incorrectly assigned reads here and there but this is just noise. We can safely exclude all reads not mapping to one of the focal species.\n\nfinaltable &lt;- finaltable %&gt;% \n  filter(str_detect(strainID, \"0403|1287|1896|1977\"))",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#samples-with-too-few-reads",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#samples-with-too-few-reads",
    "title": "Formatting Rbec output",
    "section": "6.4 Samples with too few reads",
    "text": "6.4 Samples with too few reads\nSome of the experimental pairs had streptomycin concentrations higher than any of the species individually could tolerate. We would naively expect then that neither species would grow successfully in these samples and that the overall biomass would be very low, thus resulting in a low number of recovered reads from these samples.\nTo look into this. first let’s check which samples have very low OD600 in the endpoint samples.\n\nod &lt;- read_tsv(here::here(\"_data_raw\", \"communities\", \"optical_density\", \"20240606_pairs\", \"optical_density_formatted.tsv\"))\n\nRows: 2880 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): community_id\ndbl (5): transfers, n_species, strep_conc, replicate, OD\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nfiltids &lt;- finaltable %&gt;% \n  summarize(tot = sum(count_correct), .by = c(sample, community_id, n_species, transfers, strep_conc, replicate)) %&gt;%\n  left_join(od, by = join_by(community_id, n_species, transfers, strep_conc, replicate)) %&gt;% \n  filter(transfers == 8) %&gt;% \n  arrange(tot) %&gt;% \n  arrange(OD) %&gt;% \n  filter(OD &lt; 0.1 | tot &lt; 1000) %&gt;% \n  pull(sample)\n\nWe’ll filter out samples with an OD of less than 0.1 and also samples with fewer than 1000 reads. It is genearlly good practice to exclude samples with low number of reads.\n\nfinaltable &lt;- finaltable %&gt;% \n  filter(sample %nin% filtids)",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#masterplate-samples",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#masterplate-samples",
    "title": "Formatting Rbec output",
    "section": "6.5 Masterplate samples",
    "text": "6.5 Masterplate samples\nTo set up this experiment, Milla combined the species in the planned proportions on a masterplate. Because this process was time consuming, the masterplate was stored at -80C after construction until the experiment start day when it was taken from the freezer and used to inoculate the experiment. Because Milla knows exactly which strains were added to the master plate and the plates were not allowed to grow, any strains in these samples that are not supposed to be there should be due to Illumina index cross talk and not true contamination. We can get a sense for the average index crosstalk rate from these samples and then draw a threshold of when to exclude likely false positives and when a positive is likely due to contamination.\n\nmasterplate &lt;- finaltable %&gt;%\n  filter(community_type == \"masterplate\") %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup()\n\nHere we focus on masterplate samples with species that should not be there. We exclude species that were inoculated and plot the distribution of percentages of those species\n\n\n\n\nmasterplate %&gt;% \n  # here we take advantage of the fact that for species not supposed to be in a sample\n  # the prior left_join will have filled the evo_hist category with an NA. We can then filter\n  # on this NA value\n  filter(is.na(evo_hist)) %&gt;% \n  filter(f &gt; 0) %&gt;% \n  ggplot(aes(x = f)) +\n  geom_histogram(aes(fill = strainID), bins = 20) +\n  geom_vline(xintercept = 0.01, linetype = \"dashed\") +\n  scale_fill_manual(values = hambi_colors) +\n  scale_x_continuous(trans = \"log10\",  labels = percent, guide = guide_axis(angle=90)) + \n  labs(x = \"Crosstalk frequency\", y = \"Count\") +\n  facet_grid(~strainID) + \n  annotation_logticks(sides = \"b\", color=\"grey30\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\nFigure 1: Frequency distribution of each species in masterplate samples where it should not occur. The 1% mark (commonly accepted as an acceptable Illumina cross-talk standard) is demarcated with a dashed line.\n\n\n\nGenerally, the cross talk frequency is pretty OK. For 3/4 species it is 1% or less which is more or less what you can expect when you are multiplexing libraries on an Illumina platform. Values greater than 1% are potentially indicative of a different problem, so 1977 requires a bit more investigation.\n\nsids &lt;- masterplate %&gt;% \n  filter(is.na(evo_hist)) %&gt;% \n  filter(f &gt; 0.01 & strainID == \"HAMBI_1977\") %&gt;% \n  pull(sample) \n\nmasterplate %&gt;% \n  filter(sample %in% sids) %&gt;% \n  dplyr::select(sample, strainID, count_correct, replicate, evo_hist, target_f, f)\n\n\n  \n\n\n\nIt looks like all the “problematic” samples come from plates 7 and 8 in the library prep. Plate 8 only contains the masterplate samples from trios whereas plate 7 contains both masterplate and experimental samples. Figure 2 shows that HAMBI-1977 is very abundant in many of the samples so likely the “leaky” reads come disproportionately from HAMBI-1977 which is why its crosstalk threshold may be higher (Figure 1).\n\n\n\n\nfinaltable %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # here we take advantage of the fact that for species not supposed to be in a sample\n  # the prior left_join will have filled the evo_hist category with an NA. We can then filter\n  # on this NA value\n  filter(!is.na(evo_hist)) %&gt;% \n  filter(f &gt; 0) %&gt;% \n  ggplot(aes(x = f)) +\n  geom_histogram(aes(fill = strainID), bins = 20) +\n  scale_fill_manual(values = hambi_colors) +\n  scale_x_continuous(trans = \"log10\",  labels = percent, guide = guide_axis(angle=90)) + \n  labs(x = \"Frequency in samples\", y = \"Count\") +\n  facet_grid(~strainID) + \n  annotation_logticks(sides = \"b\", color=\"grey30\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\nFigure 2: Frequency distribution of each species in all samples where it should occur.\n\n\n\nAnyway, I don’t think this is a problem and that we can move forward with these samples. However, to define extinction/competitive exclusion we may need to use a higher threshold than 1% (e.g., 3% frequency) because over 3% we can reliably say that a species is present and it is not due to index cross talk.",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#experimental-samples",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#experimental-samples",
    "title": "Formatting Rbec output",
    "section": "6.6 Experimental samples",
    "text": "6.6 Experimental samples\nNow we need to see how our experimental samples performed and if there are species present in them that shouldn’t be there\n\nexp_contam &lt;- finaltable %&gt;% \n  filter(str_detect(community_type, \"experiment\")) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # because we set 3% as our limit of detection we set read counts of species \n  # less than 1% to 0\n  mutate(count_correct_thresh = if_else(f &lt;= 0.03, 0, count_correct)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct_thresh/sum(count_correct_thresh)) %&gt;% \n  ungroup()\n\n\n\n\n\nexp_contam %&gt;% \n  filter(is.na(evo_hist)) %&gt;% \n  ggplot(aes(x = f)) +\n  geom_histogram(aes(fill = strainID), bins = 20) +\n  scale_fill_manual(values = hambi_colors) +\n  scale_x_continuous(trans = \"log10\",  labels = percent, guide = guide_axis(angle=90)) + \n  labs(x = \"Frequency in samples\", y = \"Count\") +\n  facet_grid(~ strainID) + \n  annotation_logticks(sides = \"b\", color=\"grey30\") +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"bottom\")\n\nWarning in scale_x_continuous(trans = \"log10\", labels = percent, guide =\nguide_axis(angle = 90)): log-10 transformation introduced infinite values.\n\n\nWarning: Removed 783 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Frequency distribution of each species in experimental samples where it should not occcur.\n\n\n\nIt’s not too bad… but 72 of 566 samples (12.7%) have probably been contaminated because they contain a species that shouldn’t be in the sample (using the 3% relative abundance as a robust threshold for presence/absence).\n\n6.6.1 Contaminated pairs\nTaking a closer look at specific experimental samples with contamination.\nHere we just select samples that have &gt; 3% of a species that shouldn’t be there and prepare them for plotting.\n\ncontamsampid &lt;- exp_contam %&gt;% \n  filter(f &gt; 0) %&gt;% \n  filter(is.na(evo_hist)) %&gt;% \n  pull(sample)\n\nspcols &lt;- c(\"HAMBI_0403_anc\" = \"#faa019\",\n            \"HAMBI_0403_evo\" = \"#bd7811\",\n            \"HAMBI_1287_anc\" = \"#75afff\",\n            \"HAMBI_1287_evo\" = \"#476c9e\",\n            \"HAMBI_1896_anc\" = \"#59cc4e\",\n            \"HAMBI_1896_evo\" = \"#31752a\",\n            \"HAMBI_1977_anc\" = \"#ffd430\",\n            \"HAMBI_1977_evo\" = \"#ab8e1f\",\n            \n            \"HAMBI_0403_NA\"  = \"#e6e5e3\",\n            \"HAMBI_1287_NA\"  = \"#bdbcbb\",\n            \"HAMBI_1896_NA\"  = \"#8c8c8b\",\n            \"HAMBI_1977_NA\"  = \"#333333\"\n            )\n\nexp_contam_plot &lt;- exp_contam %&gt;%\n  filter(sample %in% contamsampid) %&gt;% \n  mutate(sp = paste0(strainID, \"_\", evo_hist))\n\n\n\n\n\nexp_contam_plot %&gt;% \n  filter(n_species == 2) %&gt;% \n  ggplot() +\n  geom_col(aes(x = sample, y=f, fill = sp)) +\n  facet_wrap( ~ strep_conc, scales = \"free_x\", ncol = 2) +\n  labs(y = \"Abundance\", x = \"\", fill = \"\") +\n  scale_fill_manual(values = spcols) +\n  scale_y_continuous(labels = percent) +\n  scale_x_discrete(guide = guide_axis(angle=90)) +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"right\")\n\n\n\n\n\n\n\n\n\n\nFigure 4: Species composition of pair samples that contain &gt; 3% of a species that shouldn’t be there (shown in grey to black).\n\n\n\nI think pretty much the only way to deal with this is to inspect manually. Most of the comtaminated samples are in the 0 Streptomycin conditions. I think we should exclude samples where the contamination is very high (over ~50% of the sample) but those with 10% or less contaminant I think can be retained, and I will discard the contaminating sequences.\n\nnotcontampairs &lt;- c(\"P04_1_0\", \"P45_2_0\", \"P01_2_64\", \"P03_2_64\", \n                    \"P06_1_256\", \"P17_2_256\", \"P30_1_256\", \"P30_2_256\", \n                    \"P41_2_256\")\n\ncontampairs &lt;- setdiff(contamsampid[grepl(\"^P\", contamsampid)], notcontampairs)\n\n\n\n6.6.2 Contaminated trios\nNow we’ll do the same thing and inspect the trios.\n\n\n\n\nexp_contam_plot %&gt;% \n  filter(n_species == 3) %&gt;% \n  ggplot() +\n  geom_col(aes(x = sample, y=f, fill = sp)) +\n  labs(y = \"Abundance\", x = \"\", fill = \"\") +\n  scale_fill_manual(values = spcols) +\n  scale_y_continuous(labels = percent) +\n  scale_x_discrete(guide = guide_axis(angle=90)) +\n  theme_bw() + \n  theme(panel.grid = element_blank(),\n        legend.position = \"right\")\n\n\n\n\n\n\n\n\n\n\nFigure 5: Species composition of trio samples that contain &gt; 3% of a species that shouldn’t be there (shown in grey to black).\n\n\n\nAgain, I think we should exclude samples where the contamination is very high (over ~50% of the sample) but those with around 10% or less contaminant I think can be retained, and I will discard the contaminating sequences.\n\nnotcontamtrios &lt;- c(\"T01_2_0\", \"T02_2_0\", \"T04_2_0\", \"T05_2_0\", \"T13_2_0\", \n                    \"T14_2_0\", \"T15_1_0\", \"T15_2_0\", \"T16_1_0\", \"T16_2_0\", \n                    \"T17_2_0\", \"T18_2_0\",\"T31_2_0\", \"T45_1_0\", \"T45_2_0\", \n                    \"T55_1_0\", \"T61_1_0\", \"T61_2_0\", \"T64_1_0\", \"T64_2_0\")\n\ncontamtrios &lt;- setdiff(contamsampid[grepl(\"^T\", contamsampid)], notcontamtrios)",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#posneg-control-samples",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#posneg-control-samples",
    "title": "Formatting Rbec output",
    "section": "7.1 pos/neg control samples",
    "text": "7.1 pos/neg control samples\nSeparate out the pos/neg control samples\n\nfinaltable %&gt;% \n  filter(str_detect(community_type, \"^pos|^neg\")) %&gt;% \n  dplyr::select(-transfers, -strep_conc, -evo_hist, -target_f, -count) %&gt;% \n  write_tsv(here::here(data, \"pos_neg_ctrl_counts.tsv\"))",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#pairs",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#pairs",
    "title": "Formatting Rbec output",
    "section": "7.2 Pairs",
    "text": "7.2 Pairs\nseparate, format, and write the pair samples\n\npairs &lt;- finaltable %&gt;% \n  filter(!str_detect(community_type, \"^pos|^neg\")) %&gt;%\n  filter(n_species == 2) %&gt;% \n  filter(sample %nin% contampairs) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # because we set 3% as our limit of detection we set read counts of species \n  # less than 1% to 0\n  mutate(count_correct_thresh = if_else(f &lt;= 0.03, 0, count_correct)) %&gt;% \n  # also exclude any remaining counts from species that shouldnt be there\n  # using again the fact that evo_hist should be NA for these species\n  filter(!is.na(evo_hist)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct_thresh/sum(count_correct_thresh)) %&gt;% \n  ungroup() %&gt;%\n  dplyr::select(sample, strainID, evo_hist, count_correct, count_correct_thresh, \n                f, target_f, replicate, strep_conc, transfers, n_species, community_type, plate_well)\n\nwrite_tsv(pairs, here::here(data, \"pairs_counts.tsv\"))",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#trios",
    "href": "R/communities/amplicon/20240711_BTK_illumina_v3/01_format_rbec_tab.html#trios",
    "title": "Formatting Rbec output",
    "section": "7.3 Trios",
    "text": "7.3 Trios\n\ntrios &lt;- finaltable %&gt;% \n  filter(!str_detect(community_type, \"^pos|^neg\")) %&gt;%\n  filter(n_species == 3) %&gt;% \n  filter(sample %nin% contamtrios) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  # because we set 3% as our limit of detection we set read counts of species \n  # less than 1% to 0\n  mutate(count_correct_thresh = if_else(f &lt;= 0.03, 0, count_correct)) %&gt;% \n  # also exclude any remaining counts from species that shouldnt be there\n  # using again the fact that evo_hist should be NA for these species\n  filter(!is.na(evo_hist)) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f = count_correct_thresh/sum(count_correct_thresh)) %&gt;% \n  ungroup() %&gt;%\n  dplyr::select(sample, strainID, evo_hist, count_correct, count_correct_thresh, \n                f, target_f, replicate, strep_conc, transfers, n_species, community_type, plate_well)\n\nwrite_tsv(trios, here::here(data, \"trios_counts.tsv\"))",
    "crumbs": [
      "4. Community growth - amplicon composition",
      "i) 20240711 BTK Illumina v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html",
    "href": "R/communities/experiment_design/01_pairs.html",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)\n\n\n\n\n\ndata &lt;- here::here(\"data\", \"communities\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\nSpecies color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html#libraries",
    "href": "R/communities/experiment_design/01_pairs.html#libraries",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html#global-variables",
    "href": "R/communities/experiment_design/01_pairs.html#global-variables",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "data &lt;- here::here(\"data\", \"communities\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html#functions-and-vars",
    "href": "R/communities/experiment_design/01_pairs.html#functions-and-vars",
    "title": "Designing two-species subcommunities",
    "section": "",
    "text": "Species color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html#format-and-save",
    "href": "R/communities/experiment_design/01_pairs.html#format-and-save",
    "title": "Designing two-species subcommunities",
    "section": "2.1 Format and save",
    "text": "2.1 Format and save\n\ncombos02_filt_well %&gt;%\n  group_by(a, b) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3)) %&gt;% \n  arrange(well) %&gt;% \n  dplyr::select(microcosm_id, well, a, a_sp, a_f, b, b_sp, b_f) %&gt;% \n  readr::write_tsv(here::here(data, \"pairs_sample_composition_wide.tsv\"))\n\n\ncombos02_filt_well %&gt;% \n  group_by(a, b) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  dplyr::select(a:b, well, microcosm_id) %&gt;% \n  tidyr::pivot_longer(c(-well, -microcosm_id)) %&gt;% \n  tidyr::separate(value, c(\"evo_hist\", \"strainID\", \"target_f\")) %&gt;% \n  dplyr::mutate(evo_hist = stringr::str_to_lower(evo_hist),\n                strainID = paste0(\"HAMBI_\", strainID),\n                target_f = as.numeric(target_f)/100,\n                n_species = 2) %&gt;% \n  dplyr::select(-name) %&gt;% \n  dplyr::relocate(microcosm_id, n_species) %&gt;% \n  readr::write_tsv(here::here(data, \"pairs_sample_composition_long.tsv\"))",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html#first-pipetting-step",
    "href": "R/communities/experiment_design/01_pairs.html#first-pipetting-step",
    "title": "Designing two-species subcommunities",
    "section": "3.1 First pipetting step",
    "text": "3.1 First pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Layout for the first pipetting step for constructing pairs. Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 90% (e.g., _90) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/01_pairs.html#second-pipetting-step",
    "href": "R/communities/experiment_design/01_pairs.html#second-pipetting-step",
    "title": "Designing two-species subcommunities",
    "section": "3.2 Second pipetting step",
    "text": "3.2 Second pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Layout for the second pipetting step for constructing pairs. Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 90% (e.g., _90) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "i) Species pairs - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html",
    "href": "R/communities/experiment_design/02_trios.html",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)\n\n\n\n\n\ndata &lt;- here::here(\"data\", \"communities\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\nSpecies color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#libraries",
    "href": "R/communities/experiment_design/02_trios.html#libraries",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#global-variables",
    "href": "R/communities/experiment_design/02_trios.html#global-variables",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "data &lt;- here::here(\"data\", \"communities\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#functions-and-vars",
    "href": "R/communities/experiment_design/02_trios.html#functions-and-vars",
    "title": "Designing three-species subcommunities",
    "section": "",
    "text": "Species color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#format-and-save",
    "href": "R/communities/experiment_design/02_trios.html#format-and-save",
    "title": "Designing three-species subcommunities",
    "section": "2.1 Format and save",
    "text": "2.1 Format and save\n\ncombos03_filt_wells %&gt;%\n  group_by(a, b, c) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         c_sp = paste0(str_split_i(c, \"_\", 2), stringr::str_extract(str_split_i(c, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3),\n         c_f = str_split_i(c, \"_\", 3)) %&gt;% \n  arrange(well) %&gt;% \n  dplyr::select(microcosm_id, well, a, a_sp, a_f, b, b_sp, b_f, c, c_sp, c_f) %&gt;% \n  readr::write_tsv(here::here(data, \"trios_sample_composition_wide.tsv\"))\n\n\ncombos03_filt_wells %&gt;%\n  group_by(a, b, c) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  dplyr::select(a:c, well, microcosm_id) %&gt;% \n  tidyr::pivot_longer(c(-well, -microcosm_id)) %&gt;% \n  tidyr::separate(value, c(\"evo_hist\", \"strainID\", \"target_f\")) %&gt;% \n  dplyr::mutate(evo_hist = stringr::str_to_lower(evo_hist),\n                strainID = paste0(\"HAMBI_\", strainID),\n                target_f = as.numeric(target_f)/100,\n                n_species = 3) %&gt;% \n  dplyr::select(-name) %&gt;% \n  dplyr::relocate(microcosm_id, n_species) %&gt;% \n  readr::write_tsv(here::here(data, \"trios_sample_composition_long.tsv\"))",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#first-pipetting-step",
    "href": "R/communities/experiment_design/02_trios.html#first-pipetting-step",
    "title": "Designing three-species subcommunities",
    "section": "3.1 First pipetting step",
    "text": "3.1 First pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Layout for the first pipetting step for constructing trios Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 80% (e.g., _80) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#second-pipetting-step",
    "href": "R/communities/experiment_design/02_trios.html#second-pipetting-step",
    "title": "Designing three-species subcommunities",
    "section": "3.2 Second pipetting step",
    "text": "3.2 Second pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Layout for the second pipetting step for constructing trios Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 80% (e.g., _80) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/02_trios.html#third-pipetting-step",
    "href": "R/communities/experiment_design/02_trios.html#third-pipetting-step",
    "title": "Designing three-species subcommunities",
    "section": "3.3 Third pipetting step",
    "text": "3.3 Third pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Layout for the third pipetting step for constructing trios Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 80% (e.g., _80) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "ii) Species trios - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html",
    "href": "R/communities/experiment_design/03_quartets.html",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)\n\n\n\n\n\ndata &lt;- here::here(\"data\", \"communities\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\nSpecies color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#libraries",
    "href": "R/communities/experiment_design/03_quartets.html#libraries",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "library(here)\nlibrary(tidyverse)\nlibrary(ggplate)",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#global-variables",
    "href": "R/communities/experiment_design/03_quartets.html#global-variables",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "data &lt;- here::here(\"data\", \"communities\", \"experiment_design\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#functions-and-vars",
    "href": "R/communities/experiment_design/03_quartets.html#functions-and-vars",
    "title": "Designing four-species subcommunities",
    "section": "",
    "text": "Species color vector\n\nmy_colors &lt;- c(\n  \"ANC_0403_10\" = \"#ffaaaa\", \"ANC_0403_70\" = \"#aa0000\", \"ANC_0403_80\" = \"#aa0000\", \"ANC_0403_90\" = \"#aa0000\", \n  \"ANC_1287_10\" = \"#ffeeaa\", \"ANC_1287_70\" = \"#d4aa00\", \"ANC_1287_80\" = \"#d4aa00\", \"ANC_1287_90\" = \"#d4aa00\", \n  \"ANC_1896_10\" = \"#ccffaa\", \"ANC_1896_70\" = \"#44aa00\", \"ANC_1896_80\" = \"#44aa00\", \"ANC_1896_90\" = \"#44aa00\", \n  \"ANC_1977_10\" = \"#aaccff\", \"ANC_1977_70\" = \"#0055d4\", \"ANC_1977_80\" = \"#0055d4\", \"ANC_1977_90\" = \"#0055d4\",\n  \"EVO_0403_10\" = \"#ffaaee\", \"EVO_0403_70\" = \"#ff00cc\", \"EVO_0403_80\" = \"#ff00cc\", \"EVO_0403_90\" = \"#ff00cc\", \n  \"EVO_1287_10\" = \"#ffccaa\", \"EVO_1287_70\" = \"#ff6600\", \"EVO_1287_80\" = \"#ff6600\", \"EVO_1287_90\" = \"#ff6600\", \n  \"EVO_1896_10\" = \"#aaffee\", \"EVO_1896_70\" = \"#00ffcc\", \"EVO_1896_80\" = \"#00ffcc\", \"EVO_1896_90\" = \"#00ffcc\", \n  \"EVO_1977_10\" = \"#ccaaff\", \"EVO_1977_70\" = \"#7f2aff\", \"EVO_1977_80\" = \"#7f2aff\", \"EVO_1977_90\" = \"#7f2aff\"\n  )\n\nFor plotting plates\n\nplate_plot_steps &lt;- function(df, well_colmun, val_column, step, colr_vec){\n  ggplate::plate_plot(df,\n  position = {{ well_colmun }},\n  value = {{ val_column }},\n  colour = colr_vec,\n  plate_size = 96,\n  plate_type = \"round\"\n) + ggtitle(step)\n}",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#format-and-save",
    "href": "R/communities/experiment_design/03_quartets.html#format-and-save",
    "title": "Designing four-species subcommunities",
    "section": "2.1 Format and save",
    "text": "2.1 Format and save\n\ncombos04_filt_wells %&gt;%\n  group_by(a, b, c, d) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         c_sp = paste0(str_split_i(c, \"_\", 2), stringr::str_extract(str_split_i(c, \"_\", 1), \"^.{1}\")),\n         d_sp = paste0(str_split_i(d, \"_\", 2), stringr::str_extract(str_split_i(d, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3),\n         c_f = str_split_i(c, \"_\", 3),\n         d_f = str_split_i(d, \"_\", 3)) %&gt;% \n  arrange(well) %&gt;% \n  dplyr::select(microcosm_id, well, a, a_sp, a_f, b, b_sp, b_f, c, c_sp, c_f, d, d_sp, d_f) %&gt;% \n  readr::write_tsv(here::here(data, \"quartets_sample_composition_wide.tsv\"))\n\n\ncombos04_filt_wells %&gt;%\n  group_by(a, b, c, d) %&gt;% \n  mutate(microcosm_id = cur_group_id()) %&gt;% \n  ungroup() %&gt;% \n  dplyr::select(a:d, well, microcosm_id) %&gt;% \n  tidyr::pivot_longer(c(-well, -microcosm_id)) %&gt;% \n  tidyr::separate(value, c(\"evo_hist\", \"strainID\", \"target_f\")) %&gt;% \n  dplyr::mutate(evo_hist = stringr::str_to_lower(evo_hist),\n                strainID = paste0(\"HAMBI_\", strainID),\n                target_f = as.numeric(target_f)/100,\n                n_species = 4) %&gt;% \n  dplyr::select(-name) %&gt;% \n  dplyr::relocate(microcosm_id, n_species) %&gt;% \n  readr::write_tsv(here::here(data, \"quartets_sample_composition_long.tsv\"))",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#first-pipetting-step",
    "href": "R/communities/experiment_design/03_quartets.html#first-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.1 First pipetting step",
    "text": "3.1 First pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Layout for the first pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#second-pipetting-step",
    "href": "R/communities/experiment_design/03_quartets.html#second-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.2 Second pipetting step",
    "text": "3.2 Second pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Layout for the second pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#third-pipetting-step",
    "href": "R/communities/experiment_design/03_quartets.html#third-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.3 Third pipetting step",
    "text": "3.3 Third pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Layout for the third pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/experiment_design/03_quartets.html#fourth-pipetting-step",
    "href": "R/communities/experiment_design/03_quartets.html#fourth-pipetting-step",
    "title": "Designing four-species subcommunities",
    "section": "3.4 Fourth pipetting step",
    "text": "3.4 Fourth pipetting step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Layout for the fourth pipetting step for constructing quartets Different colors show different species/evolution combinations. The darkness of the color indicates whether a species/evolution combo is added at 70% (e.g., _70) or 10% (e.g., _10).",
    "crumbs": [
      "2. Community growth - experiment design",
      "iii) Species quartets - 96 Well plate layout"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html",
    "href": "R/communities/optical_density/01_format_plot_od.html",
    "title": "Formatting and plotting optical density data",
    "section": "",
    "text": "In the main experiment, species pairs, trios, or quartets were serially passaged every 48 hours to fresh media containing the necessary concentration of streptomycin. The experiment was terminated after 8 of these growth cycles (16 days). The optical density (600 nm) was measured on alternating serial passage/growth cycles. This notebook contains results/plots for the optical density data.",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#libraries",
    "href": "R/communities/optical_density/01_format_plot_od.html#libraries",
    "title": "Formatting and plotting optical density data",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(tidyverse)\nlibrary(ggforce)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#global-variables",
    "href": "R/communities/optical_density/01_format_plot_od.html#global-variables",
    "title": "Formatting and plotting optical density data",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"optical_density\")\ndata &lt;- here::here(\"data\", \"communities\", \"optical_density\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#read-optical-density-data",
    "href": "R/communities/optical_density/01_format_plot_od.html#read-optical-density-data",
    "title": "Formatting and plotting optical density data",
    "section": "2.3 Read optical density data",
    "text": "2.3 Read optical density data\n\npairs &lt;- readr::read_tsv(here::here(data_raw, \"20240606_pairs\", \"optical_density_formatted.tsv\"))\ntqs &lt;- readr::read_tsv(here::here(data_raw, \"20240829_tqs\", \"optical_density_formatted.tsv\")) %&gt;% \n  mutate(well = paste0(str_extract(well, \"[A-H]\"),\n                               str_pad(str_extract(well, \"\\\\d+\"), 2, side = \"left\", pad = \"0\")))",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#read-and-format-community-information",
    "href": "R/communities/optical_density/01_format_plot_od.html#read-and-format-community-information",
    "title": "Formatting and plotting optical density data",
    "section": "2.4 Read and format community information",
    "text": "2.4 Read and format community information\n\npairs_comp &lt;- readr::read_tsv(here::here(\"data\", \"communities\", \"experiment_design\", \"pairs_sample_composition.tsv\")) %&gt;%\n  dplyr::mutate(name = paste(str_to_upper(evo_hist), str_remove(strainID, \"HAMBI_\"), target_f*100, sep = \"_\")) %&gt;% \n  dplyr::select(community_id, name) %&gt;%\n  dplyr::group_by(community_id) %&gt;% \n  dplyr::mutate(id = 1:n()) %&gt;% \n  dplyr::ungroup() %&gt;% \n  tidyr::pivot_wider(names_from = id, values_from = name ) %&gt;%\n  dplyr::rename(a = `1`, b = `2`) %&gt;% \n  mutate(a_sp = paste0(str_split_i(a, \"_\", 2), stringr::str_extract(str_split_i(a, \"_\", 1), \"^.{1}\")),\n         b_sp = paste0(str_split_i(b, \"_\", 2), stringr::str_extract(str_split_i(b, \"_\", 1), \"^.{1}\")),\n         a_f = str_split_i(a, \"_\", 3),\n         b_f = str_split_i(b, \"_\", 3)) %&gt;% \n  arrange(community_id) %&gt;% \n  mutate(n_species = 2,\n         sp = paste(a_sp, b_sp, sep = \"|\"),\n         f = paste(a_f, b_f, sep = \"|\"))\n\nRows: 96 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (3): community_id, evo_hist, strainID\ndbl (1): target_f\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntrios_comp &lt;- readr::read_tsv(here::here(\"data\", \"communities\", \"experiment_design\", \"trios_sample_composition_wide.tsv\")) %&gt;% \n  dplyr::mutate(n_species = 3,\n                sp = paste(a_sp, b_sp, c_sp, sep = \"|\"),\n                f = paste(a_f, b_f, c_f, sep = \"|\"))\n\nRows: 96 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (7): well, a, a_sp, b, b_sp, c, c_sp\ndbl (4): microcosm_id, a_f, b_f, c_f\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nquart_comp &lt;- readr::read_tsv(here::here(\"data\", \"communities\", \"experiment_design\", \"quartets_sample_composition_wide.tsv\")) %&gt;% \n  mutate(n_species = 4,\n         sp = paste(a_sp, b_sp, c_sp, d_sp, sep = \"|\"),\n         f = paste(a_f, b_f, c_f, d_f, sep = \"|\"))\n\nRows: 64 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (9): well, a, a_sp, b, b_sp, c, c_sp, d, d_sp\ndbl (5): microcosm_id, a_f, b_f, c_f, d_f\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#subset-to-pairs-trios-and-quartets",
    "href": "R/communities/optical_density/01_format_plot_od.html#subset-to-pairs-trios-and-quartets",
    "title": "Formatting and plotting optical density data",
    "section": "2.5 Subset to pairs, trios, and quartets",
    "text": "2.5 Subset to pairs, trios, and quartets\nAlso we take the mean and std dev for the 2 replicates of each condition\n\npairs_combo &lt;- left_join(pairs_comp, pairs, by = join_by(community_id, n_species)) %&gt;% \n  summarize(OD_mn = mean(OD),\n            OD_sd = sd(OD),\n            .by = c(sp, f, transfers, strep_conc)) %&gt;% \n  mutate(strep_conc = as.factor(strep_conc))\n\ntrios_combo &lt;- left_join(trios_comp, tqs, by = join_by(well, n_species)) %&gt;% \n  summarize(OD_mn = mean(OD),\n            OD_sd = sd(OD),\n            .by = c(sp, f, transfers, strep_conc)) %&gt;% \n  mutate(strep_conc = as.factor(strep_conc))\n\nquart_combo &lt;- left_join(quart_comp, tqs, by = join_by(well, n_species)) %&gt;% \n  summarize(OD_mn = mean(OD),\n            OD_sd = sd(OD),\n            .by = c(sp, f, transfers, strep_conc)) %&gt;% \n  mutate(strep_conc = as.factor(strep_conc))",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#plotting-function",
    "href": "R/communities/optical_density/01_format_plot_od.html#plotting-function",
    "title": "Formatting and plotting optical density data",
    "section": "3.1 Plotting function",
    "text": "3.1 Plotting function\n\nplot_od_grid &lt;- function(df, remove_first_cycle = TRUE, ncol){\n  pj &lt;- ggplot2::position_jitterdodge(jitter.width=0.0,\n                           jitter.height = 0.0,\n                           dodge.width = 0.5,\n                           seed=9)\n  \n  df %&gt;% \n    dplyr::filter(if(remove_first_cycle) transfers &gt; 2 else transfers &gt; 0) %&gt;%\n    ggplot2::ggplot(aes(x = transfers, y = OD_mn, color = strep_conc, group = interaction(strep_conc, f))) + \n    ggplot2::geom_linerange(aes(ymin = OD_mn - OD_sd, ymax = OD_mn + OD_sd, color = strep_conc), position = pj) + \n    ggh4x::geom_pointpath(aes(shape = f), position = pj, mult = 0.2) +\n    #ggplot2::geom_point() + \n    #ggplot2::geom_line(aes(linetype = f)) + \n    ggplot2::facet_wrap(~sp, ncol = ncol) +\n    ggplot2::labs(x = \"Growth cycle\", y = \"OD600\", color = \"Strep μg/ml\", shape = \"Mix ratio\") +\n    ggplot2::scale_color_viridis_d() +\n    ggplot2::theme_bw() + \n    ggplot2::theme(strip.background = element_blank(),\n        legend.position = \"bottom\", \n        axis.text = element_text(size = 8),\n        strip.text = element_text(size = 8))\n}",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#pairs",
    "href": "R/communities/optical_density/01_format_plot_od.html#pairs",
    "title": "Formatting and plotting optical density data",
    "section": "3.2 Pairs",
    "text": "3.2 Pairs\n\nfig_pairs &lt;- plot_od_grid(pairs_combo, remove_first_cycle = TRUE, ncol = 4)\n\n# ggsave(\n#   here::here(\"figs\", \".svg\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"svg\"\n# )\n# \n# ggsave(\n#   here::here(\"figs\", \".png\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"png\"\n# )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Species pairs optical density (y-axis) over series of 48 hour growth cycles (x-axis, 16 days total). Different panels in the grid contain distinct species pairs (A = ancestral, E = strep evolved). Colors show Streptomycin concentration in μg/ml and point shape shows the initial mixing ratio of each species (in the same order as specie listed in each panel). Note that data from the first growth cycle (after 48 hours) is excluded for ease of viewing.\n\n\n\n\n3.2.1 Pairs with first growth cycle\n\n\n\n\nplot_od_grid(pairs_combo, remove_first_cycle = FALSE, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nFigure 2: As in Figure 1 but including data from the first growth cycle.",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#trios",
    "href": "R/communities/optical_density/01_format_plot_od.html#trios",
    "title": "Formatting and plotting optical density data",
    "section": "3.3 Trios",
    "text": "3.3 Trios\n\nfig_trios &lt;- plot_od_grid(trios_combo, remove_first_cycle = TRUE, ncol = 4)\n\n# ggsave(\n#   here::here(\"figs\", \".svg\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"svg\"\n# )\n# \n# ggsave(\n#   here::here(\"figs\", \".png\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"png\"\n# )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Species trios optical density (y-axis) over series of 48 hour growth cycles (x-axis, 16 days total). Different panels in the grid contain distinct species pairs (A = ancestral, E = strep evolved). Colors show Streptomycin concentration in μg/ml and point shape shows the initial mixing ratio of each species (in the same order as species listed in each panel). Note that data from the first growth cycle (after 48 hours) is excluded for ease of viewing.\n\n\n\n\n3.3.1 Trios with first growth cycle\n\n\n\n\nplot_od_grid(trios_combo, remove_first_cycle = FALSE, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nFigure 4: As in Figure 3 but including data from the first growth cycle.",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  },
  {
    "objectID": "R/communities/optical_density/01_format_plot_od.html#quartets",
    "href": "R/communities/optical_density/01_format_plot_od.html#quartets",
    "title": "Formatting and plotting optical density data",
    "section": "3.4 Quartets",
    "text": "3.4 Quartets\n\nfig_quarts &lt;- plot_od_grid(quart_combo, remove_first_cycle = TRUE, ncol = 4)\n\n# ggsave(\n#   here::here(\"figs\", \".svg\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"svg\"\n# )\n# \n# ggsave(\n#   here::here(\"figs\", \".png\"),\n#   fig01,\n#   width = 7,\n#   height = 12,\n#   units = \"in\",\n#   device = \"png\"\n# )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Species quartets optical density (y-axis) over series of 48 hour growth cycles (x-axis, 16 days total). Different panels in the grid contain distinct species pairs (A = ancestral, E = strep evolved). Colors show Streptomycin concentration in μg/ml and point shape shows the initial mixing ratio of each species (in the same order as species listed in each panel). Note that data from the first growth cycle (after 48 hours) is excluded for ease of viewing.\n\n\n\n\n3.4.1 Quartets with first growth cycle\n\n\n\n\nplot_od_grid(quart_combo, remove_first_cycle = FALSE, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nFigure 6: As in Figure 5 but including data from the first growth cycle.",
    "crumbs": [
      "3. Community growth - optical density",
      "i) Process and plot OD data"
    ]
  }
]